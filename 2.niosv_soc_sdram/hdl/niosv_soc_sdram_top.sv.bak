// Board: Terasic DE0-NANO (Cyclone IV E)
// File     : niosv_soc_example_top.sv
//-----------------------------------------------------------------------------
// Language : SystemVerilog
//-----------------------------------------------------------------------------
// Description:
//   Top level of project - NO/SMALL AMOUNT LOGIC ALLOWED AT THIS LEVEL
//-----------------------------------------------------------------------------

// Top Level - Parameters & External Pins
module niosv_soc_example_top 
#(
  parameter EXT_CLOCK_FREQ_Hz = 50000000, 
  parameter EXT_CLOCK_PERIOD_ns = 20.000,
  parameter INT_PLL_CLOCK_FREQ_Hz = 100000000, 
  parameter INT_PLL_CLOCK_PERIOD_ns = 10.000 
)(
  // Clocks:
  input         EXT_CLK_50MHz,      // Main external clock - 50 [MHz] 
  // Buttons: 
  input         BTN_RESET_n,        // push-button for main Fabric/SoC (general) reset - active-low
  input         BTN_USER_n,         // push button for user level interaction - active-low
  // DIP Switches:
  input    [3:0] DIPSW, 
  // LEDs (green) :
  output   [7:0] LEDG,
  // UART Communication: 
  input UART_RXD,
  output UART_TXD
);

  wire  int_reset_n ;  // The internal signal that is going to be used for propagating asynchronous reset for the entire system (internals)
  wire  int_hs_clock;  // This is the internal (High Speed) clock - generated by the PLL - used to drive the FPGA internals
  wire  pll_areset  ;  // This is an (output) signal we must set/clear and provide it to the NIOSV_SOC system  
  wire  pll_locked  ;  // This is an (input) signal we must read from the NIOSV_SOC system, to infer if the pll clock is locked.
  reg   [7:0] pwrup_timer ; // For the POR reset - a timer counter (unsigned) that is going to allow some time to pass. 
  logic pwrup_done ; // For the POR reset - after the initial timer expires, set this flag
  // POR (reset) generator with hold-up 
  always_ff@(posedge EXT_CLK_50MHz or negedge BTN_RESET_n)
    begin
	if(~BTN_RESET_n) // Asyncrhonous reset 
	  begin
	  int_reset_n <= 1'b0; // assert (active-low) the internal reset
	  pll_areset <= 1'b1;  // assert (active-high) the pll reset
	  pwrup_done <= 1'b0 ; // set false
	  pwrup_timer <= 7'h0; // zero the timer
	  end 
	else // Syncrhonous process
      begin 	  
	  if(pwrup_timer != 8'd127) // Check if enought the power up time had elapsed
        begin
	    int_reset_n <= 1'b0; // keep asserted (active-low) the internal reset
	    pll_areset  <= 1'b1; //  keep asserted (active-high) the internal reset
	    pwrup_done  <= 1'b0; // keep false the flag
	    pwrup_timer++ ; // increment the timer
	    end 
      else // If enough time had passed ...
	    begin
		pll_areset <= 1'b0 ; // release (deassert) the pll from reset
		if(pll_locked == 1'b1) // check whether the pll is locked.
		  begin 
		  pwrup_done <= 1'b1; // keep true flag
		  if(pwrup_done == 1'b1) // ensure that for at least 2 x ext_clk consecutive cycles we had stable pll lock
		    begin 
			int_reset_n <= 1'b1 ; // realease (deassert) the internal (global) reset
			end 
		  end 
		end
	  end
    end 		


//-----------------------------------------------------------------------------
// MODULE INSTANCIATIONS
//-----------------------------------------------------------------------------

// The Internal Clock(s) PLL - generates 100 [MHz] internal clock for driving FPGA
INT_CLKS_PLL INT_CLKS_PLL_inst (
	.areset ( pll_areset ),
	.inclk0 ( EXT_CLK_50MHz ),
	.c0 ( int_hs_clock ),
	.locked ( pll_locked )
);

// NIOS-V overall SoC - Qsys
NIOSV_SOC NIOSV_SOC_inst (
	.in_clock_bridge_in_clk_clk              (int_hs_clock),   //              in_clock_bridge_in_clk.clk
	.in_reset_bridge_in_reset_reset_n        (int_reset_n),     //            in_reset_bridge_in_reset.reset_n
    .uart_serial_com_external_connection_rxd (UART_RXD),        // uart_serial_com_external_connection.rxd
	.uart_serial_com_external_connection_txd (UART_TXD),        //                                    .txd
	.gpi0_butn_external_connection_export    (BTN_USER_n),      //       gpi0_butn_external_connection.export
	.gpi1_dipsw_external_connection_export   (DIPSW),           //      gpi1_dipsw_external_connection.export
	.gpo2_ledg_external_connection_export    (LEDG)             //       gpo2_ledg_external_connection.export
);

endmodule