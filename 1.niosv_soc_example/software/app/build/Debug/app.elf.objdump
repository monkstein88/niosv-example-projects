
app.elf:     file format elf32-littleriscv
app.elf
architecture: riscv:rv32, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010320

Program Header:
0x70000003 off    0x000057ea vaddr 0x00000000 paddr 0x00000000 align 2**0
         filesz 0x00000025 memsz 0x00000000 flags r--
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00010020 paddr 0x00010020 align 2**12
         filesz 0x00003438 memsz 0x00003438 flags r-x
    LOAD off    0x00004458 vaddr 0x00013458 paddr 0x000147d8 align 2**12
         filesz 0x00001380 memsz 0x00001380 flags rw-
    LOAD off    0x00000b58 vaddr 0x00015b58 paddr 0x00015b58 align 2**12
         filesz 0x00000000 memsz 0x000000b8 flags rw-
     TLS off    0x00004458 vaddr 0x00013458 paddr 0x000147d8 align 2**3
         filesz 0x00001380 memsz 0x00001380 flags r--

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00010000  00010000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000029c  00010020  00010020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000030f0  000102bc  000102bc  000012bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000ac  000133ac  000133ac  000043ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001380  00013458  000147d8  00004458  2**3
                  CONTENTS, ALLOC, LOAD, DATA, THREAD_LOCAL
  5 .bss          000000b8  00015b58  00015b58  00005b58  2**3
                  ALLOC
  6 .ONCHIP_PROGMEM 00000000  00015c10  00015c10  000057d8  2**0
                  CONTENTS
  7 .comment      00000012  00000000  00000000  000057d8  2**0
                  CONTENTS, READONLY
  8 .riscv.attributes 00000025  00000000  00000000  000057ea  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000648  00000000  00000000  00005810  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_info   000076f2  00000000  00000000  00005e58  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00003443  00000000  00000000  0000d54a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line   00003cac  00000000  00000000  0001098d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  00000d80  00000000  00000000  0001463c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00001335  00000000  00000000  000153bc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line_str 0000161d  00000000  00000000  000166f1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000020  00000000  00000000  00017d10  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00000118  00000000  00000000  00017d30  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 0000020d  00000000  00000000  00017e48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00010000 l    d  .entry	00000000 .entry
00010020 l    d  .exceptions	00000000 .exceptions
000102bc l    d  .text	00000000 .text
000133ac l    d  .rodata	00000000 .rodata
00013458 l    d  .rwdata	00000000 .rwdata
00015b58 l    d  .bss	00000000 .bss
00015c10 l    d  .ONCHIP_PROGMEM	00000000 .ONCHIP_PROGMEM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .riscv.attributes	00000000 .riscv.attributes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.S.obj
000103c8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 machine_trap.S.obj
00010020 l       .exceptions	00000000 save_registers
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
000103cc l     F .text	00000048 putc_wrapper
00010414 l     F .text	00000070 getc_wrapper
000134d8 l     O .rwdata	00000014 __stdio
00010484 l     F .text	000000dc alt_open_fd
00000000 l    df *ABS*	00000000 alt_load.c
000105d8 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
00010734 l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
000134f0 l     O .rwdata	00001060 JTAG_UART_DBG
00014550 l     O .rwdata	000000c4 UART_SERIAL_COM
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00010f4c l     F .text	00000238 altera_avalon_jtag_uart_irq
00011184 l     F .text	000000bc altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
000119e4 l     F .text	000000a8 altera_avalon_uart_irq
00011a8c l     F .text	000000e8 altera_avalon_uart_rxirq
00011b74 l     F .text	00000158 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00012394 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 intel_niosv_irq.c
00000000 l    df *ABS*	00000000 mtimer.c
00000000 l    df *ABS*	00000000 memcpy-asm.S.o
00000000 l    df *ABS*	00000000 stack_protector.c
00000000 l    df *ABS*	00000000 pico-exit.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l       .rwdata	00000080 _sig_func
00000000 l    df *ABS*	00000000 save-restore.o
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_getpid.c
00000000 l    df *ABS*	00000000 alt_kill.c
00000000 l    df *ABS*	00000000 errno.c
000106bc g     F .text	00000078 alt_main
00015b90 g     O .bss	00000080 alt_irq
000147d8 g       *ABS*	00000000 __flash_rwdata_start
00015c10 g       *ABS*	00000000 __alt_heap_start
00014fbc g       *ABS*	00000000 __global_pointer$
0001344c g     O .rodata	00000004 stdout
000130b4 g     F .text	0000004c .hidden __riscv_save_8
00010000 g       *ABS*	00000000 __alt_mem_ONCHIP_PROGMEM
00013458 g       *ABS*	00000000 __tls_base
00013148 g     F .text	00000018 .hidden __riscv_restore_3
00013120 g     F .text	00000040 .hidden __riscv_restore_10
00015b8c g     O .bss	00000004 __stack_chk_guard
000130b4 g     F .text	0000004c .hidden __riscv_save_11
00010000 g     F .entry	00000004 __reset
00010020 g       *ABS*	00000000 __flash_exceptions_start
00015b88 g     O .bss	00000004 errno
00015b64 g     O .bss	00000004 alt_argv
00010af4 g     F .text	00000034 usleep
000131a0 g     F .text	00000020 getpid
00013148 g     F .text	00000018 .hidden __riscv_restore_2
0001463c g     O .rwdata	00000180 alt_fd_list
00012498 g     F .text	00000120 alt_find_dev
00012eb4 g     F .text	00000024 memcpy
00012dcc g     F .text	000000ac alt_niosv_timer_sc_isr
00010560 g     F .text	00000078 alt_io_redirect
00012f68 g     F .text	00000068 puts
000132b4 g       *ABS*	00000000 __fini_array_end
000113ac g     F .text	0000022c altera_avalon_jtag_uart_read
000101b4 g     F .exceptions	00000108 handle_trap
000130a4 g     F .text	0000005c .hidden __riscv_save_12
00013120 g     F .text	00000040 .hidden __riscv_restore_11
00013100 g     F .text	00000018 .hidden __riscv_save_1
00013148 g     F .text	00000018 .hidden __riscv_restore_0
000130d0 g     F .text	00000030 .hidden __riscv_save_7
000147cc g     O .rwdata	00000004 alt_max_fd
00012f54 g     F .text	00000014 fflush
00012ed8 g     F .text	00000034 __stack_chk_init
00013134 g     F .text	0000002c .hidden __riscv_restore_5
00015c10 g       *ABS*	00000000 __bss_end
0001282c g     F .text	0000017c alt_iic_isr_register
00012a40 g     F .text	00000160 alt_tick
00012f0c  w    F .text	00000020 __stack_chk_fail
00011930 g     F .text	000000b4 altera_avalon_uart_init
00013458 g       *ABS*	00000000 __tbss_start
00012e78 g     F .text	0000003c alt_niosv_mtimecmp_interrupt_init
000129a8 g     F .text	00000098 alt_alarm_stop
00013134 g     F .text	0000002c .hidden __riscv_restore_6
000100c0 g     F .exceptions	000000f4 alt_irq_handler
00014614 g     O .rwdata	00000028 alt_dev_null
00012fd0 g     F .text	00000050 __libc_fini_array
00012c80 g     F .text	00000084 alt_niosv_mtime_get
00012378 g     F .text	0000001c alt_dcache_flush_all
000147d8 g       *ABS*	00000000 __ram_rwdata_end
000147c4 g     O .rwdata	00000008 alt_dev_list
00010b28 g     F .text	000000f8 write
00012c5c g     F .text	00000024 alt_timestamp_freq
00013458 g       *ABS*	00000000 __ram_rodata_end
000131c0 g     F .text	000000f0 kill
000130b4 g     F .text	0000004c .hidden __riscv_save_9
000130d0 g     F .text	00000030 .hidden __riscv_save_4
00015c10 g       *ABS*	00000000 end
000123c0 g     F .text	0000003c alt_dev_reg
00011f04 g     F .text	000001a8 altera_avalon_uart_write
00010e8c g     F .text	000000c0 altera_avalon_jtag_uart_init
0001c000 g       *ABS*	00000000 __alt_stack_pointer
00011878 g     F .text	00000064 altera_avalon_uart_write_fd
000118dc g     F .text	00000054 altera_avalon_uart_close_fd
000115d8 g     F .text	0000023c altera_avalon_jtag_uart_write
00013454 g     O .rodata	00000004 stdin
00013100 g     F .text	00000018 .hidden __riscv_save_3
00010320 g     F .text	000000ac _start
00015b70 g     O .bss	00000004 _alt_tick_rate
00015b78 g     O .bss	00000008 _alt_nticks
00012d60 g     F .text	0000006c alt_niosv_mtimecmp_get
00010984 g     F .text	000000fc read
00010c58 g     F .text	000000c0 alt_sys_init
000134d8 g       *ABS*	00000000 __tdata_source
00011240 g     F .text	0000006c altera_avalon_jtag_uart_close
00012f0c g     F .text	00000020 __stack_chk_fail_weak
00013458 g       *ABS*	00000000 __ram_rwdata_start
000133ac g       *ABS*	00000000 __ram_rodata_start
00015b80 g     O .bss	00000008 alt_niosv_timestamp_offset
00015b5c g     O .bss	00000004 alt_niosv_timer_interrupt_handler
00010d18 g     F .text	00000064 altera_avalon_jtag_uart_read_fd
000126f4 g     F .text	000000c8 alt_get_fd
00012218 g     F .text	00000088 alt_busy_sleep
00010de0 g     F .text	00000054 altera_avalon_jtag_uart_close_fd
00015c10 g       *ABS*	00000000 __alt_stack_base
00010e34 g     F .text	00000058 altera_avalon_jtag_uart_ioctl_fd
000130b4 g     F .text	0000004c .hidden __riscv_save_10
000125b8 g     F .text	0000013c alt_find_file
000123fc g     F .text	0000009c alt_dev_llist_insert
00013134 g     F .text	0000002c .hidden __riscv_restore_4
000132b4 g       *ABS*	00000000 __fini_array_start
00013120 g     F .text	00000040 .hidden __riscv_restore_8
000130d0 g     F .text	00000030 .hidden __riscv_save_6
00015b58 g       *ABS*	00000000 __bss_start
00013458 g       *ABS*	00000000 __tdata_start
00013458 g       *ABS*	00000000 __tdata_end
00013120 g     F .text	00000040 .hidden __riscv_restore_9
00013134 g     F .text	0000002c .hidden __riscv_restore_7
000102bc g     F .text	00000064 main
00015b68 g     O .bss	00000004 alt_envp
00010d7c g     F .text	00000064 altera_avalon_jtag_uart_write_fd
0001c000 g       *ABS*	00000000 __alt_heap_limit
00012bc4 g     F .text	00000040 alt_timestamp_start
0001c000 g       *ABS*	00000000 __heap_end
000133ac g       *ABS*	00000000 __flash_rodata_start
00010c20 g     F .text	00000038 alt_irq_init
00010a80 g     F .text	00000074 alt_release_fd
00013450 g     O .rodata	00000004 stderr
00015b60 g     O .bss	00000004 alt_argc
000147bc g     O .rwdata	00000008 alt_fs_list
00015c10 g       *ABS*	00000000 __heap_start
00013100 g     F .text	00000018 .hidden __riscv_save_2
00010020 g       *ABS*	00000000 __ram_exceptions_start
00012c04 g     F .text	00000058 alt_timestamp
000127d8 g     F .text	00000054 alt_ic_isr_register
000130d0 g     F .text	00000030 .hidden __riscv_save_5
00010020 g       .exceptions	00000000 trap_vector
000147d8 g       *ABS*	00000000 _edata
00011814 g     F .text	00000064 altera_avalon_uart_read_fd
00015c10 g       *ABS*	00000000 _end
000102bc g       *ABS*	00000000 __ram_exceptions_end
000112ac g     F .text	00000100 altera_avalon_jtag_uart_ioctl
00012ba0 g     F .text	00000024 intel_niosv_irq_init
00012f2c g     F .text	00000028 exit
0001c000 g       *ABS*	00000000 __alt_data_end
000134d8 g       *ABS*	00000000 __tbss_end
00013118 g     F .text	00000048 .hidden __riscv_restore_12
00011ccc g     F .text	00000058 altera_avalon_uart_close
00013100 g     F .text	00000018 .hidden __riscv_save_0
00013160 g     F .text	00000040 _exit
000120ac g     F .text	0000016c alt_alarm_start
00010820 g     F .text	00000164 open
000127bc g     F .text	0000001c alt_icache_flush_all
00012d04 g     F .text	0000005c alt_niosv_mtimecmp_set
00013148 g     F .text	00000018 .hidden __riscv_restore_1
00011d24 g     F .text	000001e0 altera_avalon_uart_read
000147d0 g     O .rwdata	00000008 alt_alarm_list
000122a0 g     F .text	000000d8 close
0001063c g     F .text	00000080 alt_load
00015b58 g     O .bss	00000004 alt_niosv_software_interrupt_handler
00013020 g     F .text	00000084 raise



Disassembly of section .entry:

00010000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */

    /* Jump to the _start entry point in the .text section. */
    tail _start
   10000:	3200006f          	j	10320 <_start>
	...

Disassembly of section .exceptions:

00010020 <trap_vector>:
    /* Save caller-saved registers on the stack */

#if __riscv_flen == 32 // rv32if
    addi sp, sp, -36 * 4
#elif ALT_CPU_NUM_GPR == 32 // rv32i
    addi sp, sp, -16 * 4
   10020:	fc010113          	addi	sp,sp,-64
#else // rv32e (16-bit)
    addi sp, sp, -10 * 4
#endif

    /* rv32e (16-bit), rv32i and rv32if */
    sw ra,  0 * 4(sp)
   10024:	00112023          	sw	ra,0(sp)
    sw t0,  1 * 4(sp)
   10028:	00512223          	sw	t0,4(sp)
    sw t1,  2 * 4(sp)
   1002c:	00612423          	sw	t1,8(sp)
    sw t2,  3 * 4(sp)
   10030:	00712623          	sw	t2,12(sp)
    sw a0,  4 * 4(sp)
   10034:	00a12823          	sw	a0,16(sp)
    sw a1,  5 * 4(sp)
   10038:	00b12a23          	sw	a1,20(sp)
    sw a2,  6 * 4(sp)
   1003c:	00c12c23          	sw	a2,24(sp)
    sw a3,  7 * 4(sp)
   10040:	00d12e23          	sw	a3,28(sp)
    sw a4,  8 * 4(sp)
   10044:	02e12023          	sw	a4,32(sp)
    sw a5,  9 * 4(sp)
   10048:	02f12223          	sw	a5,36(sp)

    /* rv32i and rv32if */
#if ALT_CPU_NUM_GPR == 32 
    sw a6, 10 * 4(sp)
   1004c:	03012423          	sw	a6,40(sp)
    sw a7, 11 * 4(sp)
   10050:	03112623          	sw	a7,44(sp)
    sw t3, 12 * 4(sp)
   10054:	03c12823          	sw	t3,48(sp)
    sw t4, 13 * 4(sp)
   10058:	03d12a23          	sw	t4,52(sp)
    sw t5, 14 * 4(sp)
   1005c:	03e12c23          	sw	t5,56(sp)
    sw t6, 15 * 4(sp)
   10060:	03f12e23          	sw	t6,60(sp)
    fsw fa6, 34 * 4(sp)
    fsw fa7, 35 * 4(sp)
#endif
    
    /* Call handle_trap to dispatch the correct handler, if available */
    csrr a0, mcause
   10064:	34202573          	csrr	a0,mcause
    csrr a1, mepc
   10068:	341025f3          	csrr	a1,mepc
    csrr a2, mtval
   1006c:	34302673          	csrr	a2,mtval
    jal handle_trap
   10070:	144000ef          	jal	ra,101b4 <handle_trap>
    csrw mepc, a0
   10074:	34151073          	csrw	mepc,a0

    /* Restore caller-saved registers */

    /* rv32e (16-bit), rv32i and rv32if */
    lw ra,  0 * 4(sp)
   10078:	00012083          	lw	ra,0(sp)
    lw t0,  1 * 4(sp)
   1007c:	00412283          	lw	t0,4(sp)
    lw t1,  2 * 4(sp)
   10080:	00812303          	lw	t1,8(sp)
    lw t2,  3 * 4(sp)
   10084:	00c12383          	lw	t2,12(sp)
    lw a0,  4 * 4(sp)
   10088:	01012503          	lw	a0,16(sp)
    lw a1,  5 * 4(sp)
   1008c:	01412583          	lw	a1,20(sp)
    lw a2,  6 * 4(sp)
   10090:	01812603          	lw	a2,24(sp)
    lw a3,  7 * 4(sp)
   10094:	01c12683          	lw	a3,28(sp)
    lw a4,  8 * 4(sp)
   10098:	02012703          	lw	a4,32(sp)
    lw a5,  9 * 4(sp)
   1009c:	02412783          	lw	a5,36(sp)

    /* rv32i and rv32if */
#if ALT_CPU_NUM_GPR == 32	
    lw a6, 10 * 4(sp)
   100a0:	02812803          	lw	a6,40(sp)
    lw a7, 11 * 4(sp)
   100a4:	02c12883          	lw	a7,44(sp)
    lw t3, 12 * 4(sp)
   100a8:	03012e03          	lw	t3,48(sp)
    lw t4, 13 * 4(sp)
   100ac:	03412e83          	lw	t4,52(sp)
    lw t5, 14 * 4(sp)
   100b0:	03812f03          	lw	t5,56(sp)
    lw t6, 15 * 4(sp)
   100b4:	03c12f83          	lw	t6,60(sp)
#endif

#if __riscv_flen == 32 // rv32if
    addi sp, sp, 36 * 4
#elif ALT_CPU_NUM_GPR == 32 // rv32i
	addi sp, sp, 16 * 4
   100b8:	04010113          	addi	sp,sp,64
    lw s0, 0(sp)
    lw s1, 4(sp)
    addi sp, sp, 8
#endif

    mret
   100bc:	30200073          	mret

000100c0 <alt_irq_handler>:
 * This means that if there is never a call to alt_irq_register() then
 * this function will not get linked in to the executable. This is acceptable
 * since if no handler is ever registered, then an interrupt can never occur.
 */
void alt_irq_handler (void)
{
   100c0:	fd010113          	addi	sp,sp,-48
   100c4:	02112623          	sw	ra,44(sp)
   100c8:	02812423          	sw	s0,40(sp)
   100cc:	03010413          	addi	s0,sp,48
    alt_u32 i;

    /*
     * Notify the operating system that we are at interrupt level.
     */  
    ALT_OS_INT_ENTER();
   100d0:	00000013          	nop
{
#if ALT_HAS_IRQ_SUPPORT
    alt_u32 active;
    alt_u32 enabled;

    NIOSV_READ_CSR(NIOSV_MIP_CSR, active);
   100d4:	344027f3          	csrr	a5,mip
   100d8:	fef42023          	sw	a5,-32(s0)
    NIOSV_READ_CSR(NIOSV_MIE_CSR, enabled);
   100dc:	304027f3          	csrr	a5,mie
   100e0:	fef42223          	sw	a5,-28(s0)

    // Since this is used by alt_irq_handler, we want to only process the upper 16-bits
    // --> the interrupt lines connected via Platform Designer...
    return (active & enabled) >> 16;
   100e4:	fe042703          	lw	a4,-32(s0)
   100e8:	fe442783          	lw	a5,-28(s0)
   100ec:	00f777b3          	and	a5,a4,a5
   100f0:	0107d793          	srli	a5,a5,0x10
     * reduced by finding out which interrupts are pending as late as possible.
     * Consider the case where the high priority interupt is asserted during
     * the interrupt entry sequence for a lower priority interrupt to see why
     * this is the case.
     */
    active = alt_irq_pending();
   100f4:	fcf42a23          	sw	a5,-44(s0)

    do
    {
        i = 0;
   100f8:	fc042e23          	sw	zero,-36(s0)
        mask = 1;
   100fc:	00100793          	li	a5,1
   10100:	fcf42c23          	sw	a5,-40(s0)
         * called to clear the interrupt condition.
         */

        do
        {
            if (active & mask)
   10104:	fd442703          	lw	a4,-44(s0)
   10108:	fd842783          	lw	a5,-40(s0)
   1010c:	00f777b3          	and	a5,a4,a5
   10110:	06078263          	beqz	a5,10174 <alt_irq_handler+0xb4>
            {
                alt_irq[i].handler(alt_irq[i].context); 
   10114:	000167b7          	lui	a5,0x16
   10118:	b9078713          	addi	a4,a5,-1136 # 15b90 <alt_irq>
   1011c:	fdc42783          	lw	a5,-36(s0)
   10120:	00379793          	slli	a5,a5,0x3
   10124:	00f707b3          	add	a5,a4,a5
   10128:	0007a703          	lw	a4,0(a5)
   1012c:	000167b7          	lui	a5,0x16
   10130:	b9078693          	addi	a3,a5,-1136 # 15b90 <alt_irq>
   10134:	fdc42783          	lw	a5,-36(s0)
   10138:	00379793          	slli	a5,a5,0x3
   1013c:	00f687b3          	add	a5,a3,a5
   10140:	0047a783          	lw	a5,4(a5)
   10144:	00078513          	mv	a0,a5
   10148:	000700e7          	jalr	a4
                break;
   1014c:	00000013          	nop
    NIOSV_READ_CSR(NIOSV_MIP_CSR, active);
   10150:	344027f3          	csrr	a5,mip
   10154:	fef42423          	sw	a5,-24(s0)
    NIOSV_READ_CSR(NIOSV_MIE_CSR, enabled);
   10158:	304027f3          	csrr	a5,mie
   1015c:	fef42623          	sw	a5,-20(s0)
    return (active & enabled) >> 16;
   10160:	fe842703          	lw	a4,-24(s0)
   10164:	fec42783          	lw	a5,-20(s0)
   10168:	00f777b3          	and	a5,a4,a5
   1016c:	0107d793          	srli	a5,a5,0x10
   10170:	0200006f          	j	10190 <alt_irq_handler+0xd0>
            }
            
            mask <<= 1;
   10174:	fd842783          	lw	a5,-40(s0)
   10178:	00179793          	slli	a5,a5,0x1
   1017c:	fcf42c23          	sw	a5,-40(s0)
            i++;
   10180:	fdc42783          	lw	a5,-36(s0)
   10184:	00178793          	addi	a5,a5,1
   10188:	fcf42e23          	sw	a5,-36(s0)
            if (active & mask)
   1018c:	f79ff06f          	j	10104 <alt_irq_handler+0x44>
            
        } while (1);

        active = alt_irq_pending();
   10190:	fcf42a23          	sw	a5,-44(s0)
    
    } while (active);
   10194:	fd442783          	lw	a5,-44(s0)
   10198:	f60790e3          	bnez	a5,100f8 <alt_irq_handler+0x38>

    /*
     * Notify the operating system that interrupt processing is complete.
     */ 

    ALT_OS_INT_EXIT();
   1019c:	00000013          	nop
}
   101a0:	00000013          	nop
   101a4:	02c12083          	lw	ra,44(sp)
   101a8:	02812403          	lw	s0,40(sp)
   101ac:	03010113          	addi	sp,sp,48
   101b0:	00008067          	ret

000101b4 <handle_trap>:
{
   101b4:	fd010113          	addi	sp,sp,-48
   101b8:	02112623          	sw	ra,44(sp)
   101bc:	02812423          	sw	s0,40(sp)
   101c0:	03010413          	addi	s0,sp,48
   101c4:	fca42e23          	sw	a0,-36(s0)
   101c8:	fcb42c23          	sw	a1,-40(s0)
   101cc:	fcc42a23          	sw	a2,-44(s0)
    is_irq = (cause & NIOSV_MCAUSE_INTERRUPT_MASK);
   101d0:	fdc42703          	lw	a4,-36(s0)
   101d4:	800007b7          	lui	a5,0x80000
   101d8:	00f777b3          	and	a5,a4,a5
   101dc:	fef42423          	sw	a5,-24(s0)
    exception_code = (cause & ~NIOSV_MCAUSE_INTERRUPT_MASK);
   101e0:	fdc42703          	lw	a4,-36(s0)
   101e4:	800007b7          	lui	a5,0x80000
   101e8:	fff7c793          	not	a5,a5
   101ec:	00f777b3          	and	a5,a4,a5
   101f0:	fef42623          	sw	a5,-20(s0)
    if (is_irq) {
   101f4:	fe842783          	lw	a5,-24(s0)
   101f8:	08078863          	beqz	a5,10288 <handle_trap+0xd4>
        switch (exception_code) {
   101fc:	fec42703          	lw	a4,-20(s0)
   10200:	00300793          	li	a5,3
   10204:	04f70063          	beq	a4,a5,10244 <handle_trap+0x90>
   10208:	fec42703          	lw	a4,-20(s0)
   1020c:	00700793          	li	a5,7
   10210:	06f71263          	bne	a4,a5,10274 <handle_trap+0xc0>
                if (alt_niosv_timer_interrupt_handler) {
   10214:	000167b7          	lui	a5,0x16
   10218:	b5c7a783          	lw	a5,-1188(a5) # 15b5c <alt_niosv_timer_interrupt_handler>
   1021c:	06078a63          	beqz	a5,10290 <handle_trap+0xdc>
                    ALT_OS_INT_ENTER();
   10220:	00000013          	nop
                    alt_niosv_timer_interrupt_handler(cause, epc, tval);
   10224:	000167b7          	lui	a5,0x16
   10228:	b5c7a783          	lw	a5,-1188(a5) # 15b5c <alt_niosv_timer_interrupt_handler>
   1022c:	fd442603          	lw	a2,-44(s0)
   10230:	fd842583          	lw	a1,-40(s0)
   10234:	fdc42503          	lw	a0,-36(s0)
   10238:	000780e7          	jalr	a5
                    ALT_OS_INT_EXIT();
   1023c:	00000013          	nop
                break;
   10240:	0500006f          	j	10290 <handle_trap+0xdc>
                if (alt_niosv_software_interrupt_handler) {
   10244:	000167b7          	lui	a5,0x16
   10248:	b587a783          	lw	a5,-1192(a5) # 15b58 <alt_niosv_software_interrupt_handler>
   1024c:	04078663          	beqz	a5,10298 <handle_trap+0xe4>
                    ALT_OS_INT_ENTER();
   10250:	00000013          	nop
                    alt_niosv_software_interrupt_handler(cause, epc, tval);
   10254:	000167b7          	lui	a5,0x16
   10258:	b587a783          	lw	a5,-1192(a5) # 15b58 <alt_niosv_software_interrupt_handler>
   1025c:	fd442603          	lw	a2,-44(s0)
   10260:	fd842583          	lw	a1,-40(s0)
   10264:	fdc42503          	lw	a0,-36(s0)
   10268:	000780e7          	jalr	a5
                    ALT_OS_INT_EXIT();
   1026c:	00000013          	nop
                break;
   10270:	0280006f          	j	10298 <handle_trap+0xe4>
                if (exception_code >= 16) {
   10274:	fec42703          	lw	a4,-20(s0)
   10278:	00f00793          	li	a5,15
   1027c:	02e7f263          	bgeu	a5,a4,102a0 <handle_trap+0xec>
                    alt_irq_handler();
   10280:	e41ff0ef          	jal	ra,100c0 <alt_irq_handler>
                break;
   10284:	01c0006f          	j	102a0 <handle_trap+0xec>
            NIOSV_EBREAK();
   10288:	00100073          	ebreak
   1028c:	0180006f          	j	102a4 <handle_trap+0xf0>
                break;
   10290:	00000013          	nop
   10294:	0100006f          	j	102a4 <handle_trap+0xf0>
                break;
   10298:	00000013          	nop
   1029c:	0080006f          	j	102a4 <handle_trap+0xf0>
                break;
   102a0:	00000013          	nop
    return epc;
   102a4:	fd842783          	lw	a5,-40(s0)
}
   102a8:	00078513          	mv	a0,a5
   102ac:	02c12083          	lw	ra,44(sp)
   102b0:	02812403          	lw	s0,40(sp)
   102b4:	03010113          	addi	sp,sp,48
   102b8:	00008067          	ret

Disassembly of section .text:

000102bc <main>:
#include <altera_avalon_pio_regs.h>



int main(void)
{
   102bc:	fe010113          	addi	sp,sp,-32
   102c0:	00112e23          	sw	ra,28(sp)
   102c4:	00812c23          	sw	s0,24(sp)
   102c8:	02010413          	addi	s0,sp,32
	uint8_t count = 0;
   102cc:	fe0405a3          	sb	zero,-21(s0)
    printf("\nHello from NIOS-V running on DE0-NANO!\n");
   102d0:	000137b7          	lui	a5,0x13
   102d4:	3ac78513          	addi	a0,a5,940 # 133ac <__flash_rodata_start>
   102d8:	491020ef          	jal	ra,12f68 <puts>
	fflush(stdout);
   102dc:	000137b7          	lui	a5,0x13
   102e0:	44c7a783          	lw	a5,1100(a5) # 1344c <stdout>
   102e4:	00078513          	mv	a0,a5
   102e8:	46d020ef          	jal	ra,12f54 <fflush>
    while(1)
    {
    	IOWR_ALTERA_AVALON_PIO_DATA(GPO2_LEDG_BASE, count++);
   102ec:	feb44783          	lbu	a5,-21(s0)
   102f0:	00178713          	addi	a4,a5,1
   102f4:	fee405a3          	sb	a4,-21(s0)
   102f8:	fef42623          	sw	a5,-20(s0)
   102fc:	000207b7          	lui	a5,0x20
   10300:	04078793          	addi	a5,a5,64 # 20040 <__alt_data_end+0x4040>
   10304:	fec42703          	lw	a4,-20(s0)
   10308:	00e7a023          	sw	a4,0(a5)
        usleep(100000);
   1030c:	000187b7          	lui	a5,0x18
   10310:	6a078513          	addi	a0,a5,1696 # 186a0 <__alt_heap_start+0x2a90>
   10314:	7e0000ef          	jal	ra,10af4 <usleep>
    	IOWR_ALTERA_AVALON_PIO_DATA(GPO2_LEDG_BASE, count++);
   10318:	00000013          	nop
   1031c:	fd1ff06f          	j	102ec <main+0x30>

00010320 <_start>:
    .type _start, @function
_start:
#if ALT_CPU_HAS_CSR_SUPPORT
    /* assume that we are in machine mode on startup */
    /* setup trap to catch anything that goes wrong early in the boot process */
    la t0, trap_vector
   10320:	00000297          	auipc	t0,0x0
   10324:	d0028293          	addi	t0,t0,-768 # 10020 <__flash_exceptions_start>
    csrw mtvec, t0
   10328:	30529073          	csrw	mtvec,t0

    /* disable all interrupt */
    li t0, 0x88
   1032c:	08800293          	li	t0,136
    csrc mstatus, t0
   10330:	3002b073          	csrc	mstatus,t0
    csrw mie, zero
   10334:	30401073          	csrw	mie,zero
    csrw mip, zero
   10338:	34401073          	csrw	mip,zero
#endif /* Initialize Data Cache */
#endif /* ALT_SIM_OPTIMIZE */

    .option push
    .option norelax
    la gp, __global_pointer$
   1033c:	00005197          	auipc	gp,0x5
   10340:	c8018193          	addi	gp,gp,-896 # 14fbc <__global_pointer$>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    la sp, __alt_stack_pointer
   10344:	0000c117          	auipc	sp,0xc
   10348:	cbc10113          	addi	sp,sp,-836 # 1c000 <__alt_data_end>
    /* Log that the BSS is about to be cleared. */
#ifdef ALT_LOG_ENABLE
    ALT_LOG_PUTS(alt_log_msg_bss)
#endif /* ALT_LOG_ENABLE */

    la t1, __bss_start
   1034c:	00006317          	auipc	t1,0x6
   10350:	80c30313          	addi	t1,t1,-2036 # 15b58 <alt_niosv_software_interrupt_handler>
    la t2, __bss_end
   10354:	00006397          	auipc	t2,0x6
   10358:	8bc38393          	addi	t2,t2,-1860 # 15c10 <__alt_heap_start>
0:
    sw zero, (t1)
   1035c:	00032023          	sw	zero,0(t1)
    addi t1, t1, 4
   10360:	00430313          	addi	t1,t1,4
    bltu t1, t2, 0b
   10364:	fe736ce3          	bltu	t1,t2,1035c <_start+0x3c>
/*
 * The alt_load() facility is normally used when there is no bootloader.
 * It copies some sections into RAM so it acts like a mini-bootloader.
 */
#ifdef CALL_ALT_LOAD
    call alt_load
   10368:	2d4000ef          	jal	ra,1063c <alt_load>
 */
#ifndef ALT_SIM_OPTIMIZE
.globl __tbss_start
.globl __tbss_end

    la t1, __tbss_start
   1036c:	00003317          	auipc	t1,0x3
   10370:	0ec30313          	addi	t1,t1,236 # 13458 <__ram_rodata_end>
    la t2, __tbss_end
   10374:	00003397          	auipc	t2,0x3
   10378:	16438393          	addi	t2,t2,356 # 134d8 <__stdio>
    
    // Check if we need to skip this (if .tbss is empty)
    bgeu t1, t2, 1f
   1037c:	00737863          	bgeu	t1,t2,1038c <_start+0x6c>
0:
    sw zero, (t1)
   10380:	00032023          	sw	zero,0(t1)
    addi t1, t1, 4
   10384:	00430313          	addi	t1,t1,4
    bltu t1, t2, 0b
   10388:	fe736ce3          	bltu	t1,t2,10380 <_start+0x60>
// Copy tdata to tdata golden source location
.globl __tdata_start
.globl __tdata_end
.globl __tdata_source

    la t0, __tdata_start
   1038c:	00003297          	auipc	t0,0x3
   10390:	0cc28293          	addi	t0,t0,204 # 13458 <__ram_rodata_end>
    la t1, __tdata_end
   10394:	00003317          	auipc	t1,0x3
   10398:	0c430313          	addi	t1,t1,196 # 13458 <__ram_rodata_end>
    la t2, __tdata_source
   1039c:	00003397          	auipc	t2,0x3
   103a0:	13c38393          	addi	t2,t2,316 # 134d8 <__stdio>

    // Check if we need to skip this (if .tdata is empty)
    bgeu t0, t1, 1f
   103a4:	0062fc63          	bgeu	t0,t1,103bc <_start+0x9c>
0:
    lw s1, (t0)
   103a8:	0002a483          	lw	s1,0(t0)
    sw s1, (t2)
   103ac:	0093a023          	sw	s1,0(t2)
    addi t0, t0, 4
   103b0:	00428293          	addi	t0,t0,4
    addi t2, t2, 4
   103b4:	00438393          	addi	t2,t2,4
    bltu t0, t1, 0b
   103b8:	fe62e8e3          	bltu	t0,t1,103a8 <_start+0x88>
1:

// Assign thread pointer register (tp) to main thread tls base
.globl __tls_base
    la tp, __tls_base
   103bc:	00003217          	auipc	tp,0x3
   103c0:	09c20213          	addi	tp,tp,156 # 13458 <__ram_rodata_end>
#ifdef ALT_LOG_ENABLE
    ALT_LOG_PUTS(alt_log_msg_alt_main)
#endif /* ALT_LOG_ENABLE */

    /* Call the C entry point. It should never return. */
    call alt_main
   103c4:	2f8000ef          	jal	ra,106bc <alt_main>

000103c8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    j alt_after_alt_main
   103c8:	0000006f          	j	103c8 <alt_after_alt_main>

000103cc <putc_wrapper>:
   103cc:	fe010113          	addi	sp,sp,-32
   103d0:	00112e23          	sw	ra,28(sp)
#include "sys/alt_dev.h"
#include "priv/alt_file.h"

#ifdef USE_PICOLIBC

static int putc_wrapper(char c, FILE *fp) {
   103d4:	00812c23          	sw	s0,24(sp)
   103d8:	02010413          	addi	s0,sp,32
   103dc:	00050793          	mv	a5,a0
   103e0:	feb42423          	sw	a1,-24(s0)
   103e4:	fef407a3          	sb	a5,-17(s0)
    return write(STDOUT_FILENO, &c, 1);
   103e8:	fef40793          	addi	a5,s0,-17
   103ec:	00100613          	li	a2,1
   103f0:	00078593          	mv	a1,a5
   103f4:	00100513          	li	a0,1
   103f8:	730000ef          	jal	ra,10b28 <write>
   103fc:	00050793          	mv	a5,a0
}
   10400:	00078513          	mv	a0,a5
   10404:	01c12083          	lw	ra,28(sp)
   10408:	01812403          	lw	s0,24(sp)
   1040c:	02010113          	addi	sp,sp,32
   10410:	00008067          	ret

00010414 <getc_wrapper>:

static int getc_wrapper(FILE *fp) {
   10414:	fd010113          	addi	sp,sp,-48
   10418:	02112623          	sw	ra,44(sp)
   1041c:	02812423          	sw	s0,40(sp)
   10420:	03010413          	addi	s0,sp,48
   10424:	fca42e23          	sw	a0,-36(s0)
   10428:	000167b7          	lui	a5,0x16
   1042c:	b8c7a703          	lw	a4,-1140(a5) # 15b8c <__stack_chk_guard>
   10430:	fee42623          	sw	a4,-20(s0)
   10434:	00000713          	li	a4,0
    unsigned char c;
    read(STDIN_FILENO, &c, 1);
   10438:	feb40793          	addi	a5,s0,-21
   1043c:	00100613          	li	a2,1
   10440:	00078593          	mv	a1,a5
   10444:	00000513          	li	a0,0
   10448:	53c000ef          	jal	ra,10984 <read>
    return c;
   1044c:	feb44783          	lbu	a5,-21(s0)
   10450:	00078713          	mv	a4,a5
}
   10454:	000167b7          	lui	a5,0x16
   10458:	fec42683          	lw	a3,-20(s0)
   1045c:	b8c7a783          	lw	a5,-1140(a5) # 15b8c <__stack_chk_guard>
   10460:	00f6c7b3          	xor	a5,a3,a5
   10464:	00000693          	li	a3,0
   10468:	00078463          	beqz	a5,10470 <getc_wrapper+0x5c>
   1046c:	2a1020ef          	jal	ra,12f0c <__stack_chk_fail_weak>
   10470:	00070513          	mv	a0,a4
   10474:	02c12083          	lw	ra,44(sp)
   10478:	02812403          	lw	s0,40(sp)
   1047c:	03010113          	addi	sp,sp,48
   10480:	00008067          	ret

00010484 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   10484:	fd010113          	addi	sp,sp,-48
   10488:	02112623          	sw	ra,44(sp)
   1048c:	02812423          	sw	s0,40(sp)
   10490:	03010413          	addi	s0,sp,48
   10494:	fca42e23          	sw	a0,-36(s0)
   10498:	fcb42c23          	sw	a1,-40(s0)
   1049c:	fcc42a23          	sw	a2,-44(s0)
   104a0:	fcd42823          	sw	a3,-48(s0)
  int old;

  old = open (name, flags, mode);
   104a4:	fd042603          	lw	a2,-48(s0)
   104a8:	fd442583          	lw	a1,-44(s0)
   104ac:	fd842503          	lw	a0,-40(s0)
   104b0:	370000ef          	jal	ra,10820 <open>
   104b4:	fea42623          	sw	a0,-20(s0)

  if (old >= 0)
   104b8:	fec42783          	lw	a5,-20(s0)
   104bc:	0807c863          	bltz	a5,1054c <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
   104c0:	000147b7          	lui	a5,0x14
   104c4:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   104c8:	fec42703          	lw	a4,-20(s0)
   104cc:	00070793          	mv	a5,a4
   104d0:	00179793          	slli	a5,a5,0x1
   104d4:	00e787b3          	add	a5,a5,a4
   104d8:	00279793          	slli	a5,a5,0x2
   104dc:	00f687b3          	add	a5,a3,a5
   104e0:	0007a703          	lw	a4,0(a5)
   104e4:	fdc42783          	lw	a5,-36(s0)
   104e8:	00e7a023          	sw	a4,0(a5)
    fd->priv     = alt_fd_list[old].priv;
   104ec:	000147b7          	lui	a5,0x14
   104f0:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   104f4:	fec42703          	lw	a4,-20(s0)
   104f8:	00070793          	mv	a5,a4
   104fc:	00179793          	slli	a5,a5,0x1
   10500:	00e787b3          	add	a5,a5,a4
   10504:	00279793          	slli	a5,a5,0x2
   10508:	00f687b3          	add	a5,a3,a5
   1050c:	0047a703          	lw	a4,4(a5)
   10510:	fdc42783          	lw	a5,-36(s0)
   10514:	00e7a223          	sw	a4,4(a5)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   10518:	000147b7          	lui	a5,0x14
   1051c:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   10520:	fec42703          	lw	a4,-20(s0)
   10524:	00070793          	mv	a5,a4
   10528:	00179793          	slli	a5,a5,0x1
   1052c:	00e787b3          	add	a5,a5,a4
   10530:	00279793          	slli	a5,a5,0x2
   10534:	00f687b3          	add	a5,a3,a5
   10538:	0087a703          	lw	a4,8(a5)
   1053c:	fdc42783          	lw	a5,-36(s0)
   10540:	00e7a423          	sw	a4,8(a5)

    alt_release_fd (old);
   10544:	fec42503          	lw	a0,-20(s0)
   10548:	538000ef          	jal	ra,10a80 <alt_release_fd>
  }
} 
   1054c:	00000013          	nop
   10550:	02c12083          	lw	ra,44(sp)
   10554:	02812403          	lw	s0,40(sp)
   10558:	03010113          	addi	sp,sp,48
   1055c:	00008067          	ret

00010560 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   10560:	fe010113          	addi	sp,sp,-32
   10564:	00112e23          	sw	ra,28(sp)
   10568:	00812c23          	sw	s0,24(sp)
   1056c:	02010413          	addi	s0,sp,32
   10570:	fea42623          	sw	a0,-20(s0)
   10574:	feb42423          	sw	a1,-24(s0)
   10578:	fec42223          	sw	a2,-28(s0)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   1057c:	1ff00693          	li	a3,511
   10580:	00100613          	li	a2,1
   10584:	fec42583          	lw	a1,-20(s0)
   10588:	000147b7          	lui	a5,0x14
   1058c:	64878513          	addi	a0,a5,1608 # 14648 <alt_fd_list+0xc>
   10590:	ef5ff0ef          	jal	ra,10484 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   10594:	1ff00693          	li	a3,511
   10598:	00000613          	li	a2,0
   1059c:	fe842583          	lw	a1,-24(s0)
   105a0:	000147b7          	lui	a5,0x14
   105a4:	63c78513          	addi	a0,a5,1596 # 1463c <alt_fd_list>
   105a8:	eddff0ef          	jal	ra,10484 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   105ac:	1ff00693          	li	a3,511
   105b0:	00100613          	li	a2,1
   105b4:	fe442583          	lw	a1,-28(s0)
   105b8:	000147b7          	lui	a5,0x14
   105bc:	65478513          	addi	a0,a5,1620 # 14654 <alt_fd_list+0x18>
   105c0:	ec5ff0ef          	jal	ra,10484 <alt_open_fd>
}  
   105c4:	00000013          	nop
   105c8:	01c12083          	lw	ra,28(sp)
   105cc:	01812403          	lw	s0,24(sp)
   105d0:	02010113          	addi	sp,sp,32
   105d4:	00008067          	ret

000105d8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   105d8:	fe010113          	addi	sp,sp,-32
   105dc:	00812e23          	sw	s0,28(sp)
   105e0:	02010413          	addi	s0,sp,32
   105e4:	fea42623          	sw	a0,-20(s0)
   105e8:	feb42423          	sw	a1,-24(s0)
   105ec:	fec42223          	sw	a2,-28(s0)
  if (to != from)
   105f0:	fe842703          	lw	a4,-24(s0)
   105f4:	fec42783          	lw	a5,-20(s0)
   105f8:	02f70a63          	beq	a4,a5,1062c <alt_load_section+0x54>
  {
    while( to != end )
   105fc:	0240006f          	j	10620 <alt_load_section+0x48>
    {
      *to++ = *from++;
   10600:	fec42703          	lw	a4,-20(s0)
   10604:	00470793          	addi	a5,a4,4
   10608:	fef42623          	sw	a5,-20(s0)
   1060c:	fe842783          	lw	a5,-24(s0)
   10610:	00478693          	addi	a3,a5,4
   10614:	fed42423          	sw	a3,-24(s0)
   10618:	00072703          	lw	a4,0(a4)
   1061c:	00e7a023          	sw	a4,0(a5)
    while( to != end )
   10620:	fe842703          	lw	a4,-24(s0)
   10624:	fe442783          	lw	a5,-28(s0)
   10628:	fcf71ce3          	bne	a4,a5,10600 <alt_load_section+0x28>
    }
  }
}
   1062c:	00000013          	nop
   10630:	01c12403          	lw	s0,28(sp)
   10634:	02010113          	addi	sp,sp,32
   10638:	00008067          	ret

0001063c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   1063c:	ff010113          	addi	sp,sp,-16
   10640:	00112623          	sw	ra,12(sp)
   10644:	00812423          	sw	s0,8(sp)
   10648:	01010413          	addi	s0,sp,16
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   1064c:	000147b7          	lui	a5,0x14
   10650:	7d878613          	addi	a2,a5,2008 # 147d8 <__flash_rwdata_start>
   10654:	000137b7          	lui	a5,0x13
   10658:	45878593          	addi	a1,a5,1112 # 13458 <__ram_rodata_end>
   1065c:	000147b7          	lui	a5,0x14
   10660:	7d878513          	addi	a0,a5,2008 # 147d8 <__flash_rwdata_start>
   10664:	f75ff0ef          	jal	ra,105d8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   10668:	000107b7          	lui	a5,0x10
   1066c:	2bc78613          	addi	a2,a5,700 # 102bc <main>
   10670:	000107b7          	lui	a5,0x10
   10674:	02078593          	addi	a1,a5,32 # 10020 <__flash_exceptions_start>
   10678:	000107b7          	lui	a5,0x10
   1067c:	02078513          	addi	a0,a5,32 # 10020 <__flash_exceptions_start>
   10680:	f59ff0ef          	jal	ra,105d8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   10684:	000137b7          	lui	a5,0x13
   10688:	45878613          	addi	a2,a5,1112 # 13458 <__ram_rodata_end>
   1068c:	000137b7          	lui	a5,0x13
   10690:	3ac78593          	addi	a1,a5,940 # 133ac <__flash_rodata_start>
   10694:	000137b7          	lui	a5,0x13
   10698:	3ac78513          	addi	a0,a5,940 # 133ac <__flash_rodata_start>
   1069c:	f3dff0ef          	jal	ra,105d8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   106a0:	4d9010ef          	jal	ra,12378 <alt_dcache_flush_all>
  alt_icache_flush_all();
   106a4:	118020ef          	jal	ra,127bc <alt_icache_flush_all>
}
   106a8:	00000013          	nop
   106ac:	00c12083          	lw	ra,12(sp)
   106b0:	00812403          	lw	s0,8(sp)
   106b4:	01010113          	addi	sp,sp,16
   106b8:	00008067          	ret

000106bc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   106bc:	fe010113          	addi	sp,sp,-32
   106c0:	00112e23          	sw	ra,28(sp)
   106c4:	00812c23          	sw	s0,24(sp)
   106c8:	02010413          	addi	s0,sp,32
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   106cc:	00000513          	li	a0,0
   106d0:	550000ef          	jal	ra,10c20 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   106d4:	00000013          	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   106d8:	580000ef          	jal	ra,10c58 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   106dc:	000137b7          	lui	a5,0x13
   106e0:	3d478613          	addi	a2,a5,980 # 133d4 <__flash_rodata_start+0x28>
   106e4:	000137b7          	lui	a5,0x13
   106e8:	3d478593          	addi	a1,a5,980 # 133d4 <__flash_rodata_start+0x28>
   106ec:	000137b7          	lui	a5,0x13
   106f0:	3d478513          	addi	a0,a5,980 # 133d4 <__flash_rodata_start+0x28>
   106f4:	e6dff0ef          	jal	ra,10560 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   106f8:	000167b7          	lui	a5,0x16
   106fc:	b607a703          	lw	a4,-1184(a5) # 15b60 <alt_argc>
   10700:	000167b7          	lui	a5,0x16
   10704:	b647a683          	lw	a3,-1180(a5) # 15b64 <alt_argv>
   10708:	000167b7          	lui	a5,0x16
   1070c:	b687a783          	lw	a5,-1176(a5) # 15b68 <alt_envp>
   10710:	00078613          	mv	a2,a5
   10714:	00068593          	mv	a1,a3
   10718:	00070513          	mv	a0,a4
   1071c:	ba1ff0ef          	jal	ra,102bc <main>
   10720:	fea42623          	sw	a0,-20(s0)
  close(STDOUT_FILENO);
   10724:	00100513          	li	a0,1
   10728:	379010ef          	jal	ra,122a0 <close>
  exit (result);
   1072c:	fec42503          	lw	a0,-20(s0)
   10730:	7fc020ef          	jal	ra,12f2c <exit>

00010734 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   10734:	fd010113          	addi	sp,sp,-48
   10738:	02812623          	sw	s0,44(sp)
   1073c:	03010413          	addi	s0,sp,48
   10740:	fca42e23          	sw	a0,-36(s0)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   10744:	fdc42783          	lw	a5,-36(s0)
   10748:	0087a703          	lw	a4,8(a5)
   1074c:	400007b7          	lui	a5,0x40000
   10750:	00f76733          	or	a4,a4,a5
   10754:	fdc42783          	lw	a5,-36(s0)
   10758:	00e7a423          	sw	a4,8(a5) # 40000008 <__alt_data_end+0x3ffe4008>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   1075c:	fe042623          	sw	zero,-20(s0)
   10760:	0980006f          	j	107f8 <alt_file_locked+0xc4>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   10764:	000147b7          	lui	a5,0x14
   10768:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   1076c:	fec42703          	lw	a4,-20(s0)
   10770:	00070793          	mv	a5,a4
   10774:	00179793          	slli	a5,a5,0x1
   10778:	00e787b3          	add	a5,a5,a4
   1077c:	00279793          	slli	a5,a5,0x2
   10780:	00f687b3          	add	a5,a3,a5
   10784:	0007a703          	lw	a4,0(a5)
   10788:	fdc42783          	lw	a5,-36(s0)
   1078c:	0007a783          	lw	a5,0(a5)
   10790:	04f71e63          	bne	a4,a5,107ec <alt_file_locked+0xb8>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   10794:	000147b7          	lui	a5,0x14
   10798:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   1079c:	fec42703          	lw	a4,-20(s0)
   107a0:	00070793          	mv	a5,a4
   107a4:	00179793          	slli	a5,a5,0x1
   107a8:	00e787b3          	add	a5,a5,a4
   107ac:	00279793          	slli	a5,a5,0x2
   107b0:	00f687b3          	add	a5,a3,a5
   107b4:	0087a783          	lw	a5,8(a5)
    if ((alt_fd_list[i].dev == fd->dev) &&
   107b8:	0207da63          	bgez	a5,107ec <alt_file_locked+0xb8>
        (&alt_fd_list[i] != fd))
   107bc:	fec42703          	lw	a4,-20(s0)
   107c0:	00070793          	mv	a5,a4
   107c4:	00179793          	slli	a5,a5,0x1
   107c8:	00e787b3          	add	a5,a5,a4
   107cc:	00279793          	slli	a5,a5,0x2
   107d0:	00014737          	lui	a4,0x14
   107d4:	63c70713          	addi	a4,a4,1596 # 1463c <alt_fd_list>
   107d8:	00e787b3          	add	a5,a5,a4
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   107dc:	fdc42703          	lw	a4,-36(s0)
   107e0:	00f70663          	beq	a4,a5,107ec <alt_file_locked+0xb8>
    {
      return -EACCES;
   107e4:	ff300793          	li	a5,-13
   107e8:	0280006f          	j	10810 <alt_file_locked+0xdc>
  for (i = 0; i <= alt_max_fd; i++)
   107ec:	fec42783          	lw	a5,-20(s0)
   107f0:	00178793          	addi	a5,a5,1
   107f4:	fef42623          	sw	a5,-20(s0)
   107f8:	000147b7          	lui	a5,0x14
   107fc:	7cc7a783          	lw	a5,1996(a5) # 147cc <alt_max_fd>
   10800:	00078713          	mv	a4,a5
   10804:	fec42783          	lw	a5,-20(s0)
   10808:	f4f77ee3          	bgeu	a4,a5,10764 <alt_file_locked+0x30>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   1080c:	00000793          	li	a5,0
}
   10810:	00078513          	mv	a0,a5
   10814:	02c12403          	lw	s0,44(sp)
   10818:	03010113          	addi	sp,sp,48
   1081c:	00008067          	ret

00010820 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   10820:	fc010113          	addi	sp,sp,-64
   10824:	02112e23          	sw	ra,60(sp)
   10828:	02812c23          	sw	s0,56(sp)
   1082c:	04010413          	addi	s0,sp,64
   10830:	fca42623          	sw	a0,-52(s0)
   10834:	fcb42423          	sw	a1,-56(s0)
   10838:	fcc42223          	sw	a2,-60(s0)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   1083c:	fff00793          	li	a5,-1
   10840:	fef42023          	sw	a5,-32(s0)
  int status = -ENODEV;
   10844:	fed00793          	li	a5,-19
   10848:	fef42223          	sw	a5,-28(s0)
  int isafs = 0;
   1084c:	fe042423          	sw	zero,-24(s0)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   10850:	000147b7          	lui	a5,0x14
   10854:	7c478593          	addi	a1,a5,1988 # 147c4 <alt_dev_list>
   10858:	fcc42503          	lw	a0,-52(s0)
   1085c:	43d010ef          	jal	ra,12498 <alt_find_dev>
   10860:	fca42e23          	sw	a0,-36(s0)
   10864:	fdc42783          	lw	a5,-36(s0)
   10868:	00079c63          	bnez	a5,10880 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   1086c:	fcc42503          	lw	a0,-52(s0)
   10870:	549010ef          	jal	ra,125b8 <alt_find_file>
   10874:	fca42e23          	sw	a0,-36(s0)
    isafs = 1;
   10878:	00100793          	li	a5,1
   1087c:	fef42423          	sw	a5,-24(s0)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   10880:	fdc42783          	lw	a5,-36(s0)
   10884:	0a078c63          	beqz	a5,1093c <open+0x11c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   10888:	fdc42503          	lw	a0,-36(s0)
   1088c:	669010ef          	jal	ra,126f4 <alt_get_fd>
   10890:	fea42023          	sw	a0,-32(s0)
   10894:	fe042783          	lw	a5,-32(s0)
   10898:	0007d863          	bgez	a5,108a8 <open+0x88>
    {
      status = index;
   1089c:	fe042783          	lw	a5,-32(s0)
   108a0:	fef42223          	sw	a5,-28(s0)
   108a4:	0a00006f          	j	10944 <open+0x124>
    }
    else
    {
      fd = &alt_fd_list[index];
   108a8:	fe042703          	lw	a4,-32(s0)
   108ac:	00070793          	mv	a5,a4
   108b0:	00179793          	slli	a5,a5,0x1
   108b4:	00e787b3          	add	a5,a5,a4
   108b8:	00279793          	slli	a5,a5,0x2
   108bc:	00014737          	lui	a4,0x14
   108c0:	63c70713          	addi	a4,a4,1596 # 1463c <alt_fd_list>
   108c4:	00e787b3          	add	a5,a5,a4
   108c8:	fef42623          	sw	a5,-20(s0)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   108cc:	fc842703          	lw	a4,-56(s0)
   108d0:	400007b7          	lui	a5,0x40000
   108d4:	fff78793          	addi	a5,a5,-1 # 3fffffff <__alt_data_end+0x3ffe3fff>
   108d8:	00f77733          	and	a4,a4,a5
   108dc:	fec42783          	lw	a5,-20(s0)
   108e0:	00e7a423          	sw	a4,8(a5)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   108e4:	fe842783          	lw	a5,-24(s0)
   108e8:	00079c63          	bnez	a5,10900 <open+0xe0>
   108ec:	fec42503          	lw	a0,-20(s0)
   108f0:	e45ff0ef          	jal	ra,10734 <alt_file_locked>
   108f4:	fea42223          	sw	a0,-28(s0)
   108f8:	fe442783          	lw	a5,-28(s0)
   108fc:	0407c463          	bltz	a5,10944 <open+0x124>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   10900:	fdc42783          	lw	a5,-36(s0)
   10904:	00c7a783          	lw	a5,12(a5)
   10908:	02078463          	beqz	a5,10930 <open+0x110>
   1090c:	fdc42783          	lw	a5,-36(s0)
   10910:	00c7a783          	lw	a5,12(a5)
   10914:	fc442683          	lw	a3,-60(s0)
   10918:	fc842603          	lw	a2,-56(s0)
   1091c:	fcc42583          	lw	a1,-52(s0)
   10920:	fec42503          	lw	a0,-20(s0)
   10924:	000780e7          	jalr	a5
   10928:	00050793          	mv	a5,a0
   1092c:	0080006f          	j	10934 <open+0x114>
   10930:	00000793          	li	a5,0
   10934:	fef42223          	sw	a5,-28(s0)
   10938:	00c0006f          	j	10944 <open+0x124>
      }
    }
  }
  else
  {
    status = -ENODEV;
   1093c:	fed00793          	li	a5,-19
   10940:	fef42223          	sw	a5,-28(s0)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   10944:	fe442783          	lw	a5,-28(s0)
   10948:	0207d263          	bgez	a5,1096c <open+0x14c>
  {
    alt_release_fd (index);  
   1094c:	fe042503          	lw	a0,-32(s0)
   10950:	130000ef          	jal	ra,10a80 <alt_release_fd>
    ALT_ERRNO = -status;
   10954:	fe442783          	lw	a5,-28(s0)
   10958:	40f00733          	neg	a4,a5
   1095c:	000167b7          	lui	a5,0x16
   10960:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
    return -1;
   10964:	fff00793          	li	a5,-1
   10968:	0080006f          	j	10970 <open+0x150>
  }
  
  /* return the reference upon success */

  return index;
   1096c:	fe042783          	lw	a5,-32(s0)
}
   10970:	00078513          	mv	a0,a5
   10974:	03c12083          	lw	ra,60(sp)
   10978:	03812403          	lw	s0,56(sp)
   1097c:	04010113          	addi	sp,sp,64
   10980:	00008067          	ret

00010984 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   10984:	fd010113          	addi	sp,sp,-48
   10988:	02112623          	sw	ra,44(sp)
   1098c:	02812423          	sw	s0,40(sp)
   10990:	03010413          	addi	s0,sp,48
   10994:	fca42e23          	sw	a0,-36(s0)
   10998:	fcb42c23          	sw	a1,-40(s0)
   1099c:	fcc42a23          	sw	a2,-44(s0)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   109a0:	fdc42783          	lw	a5,-36(s0)
   109a4:	0207c463          	bltz	a5,109cc <read+0x48>
   109a8:	fdc42703          	lw	a4,-36(s0)
   109ac:	00070793          	mv	a5,a4
   109b0:	00179793          	slli	a5,a5,0x1
   109b4:	00e787b3          	add	a5,a5,a4
   109b8:	00279793          	slli	a5,a5,0x2
   109bc:	00014737          	lui	a4,0x14
   109c0:	63c70713          	addi	a4,a4,1596 # 1463c <alt_fd_list>
   109c4:	00e787b3          	add	a5,a5,a4
   109c8:	0080006f          	j	109d0 <read+0x4c>
   109cc:	00000793          	li	a5,0
   109d0:	fef42423          	sw	a5,-24(s0)
  
  if (fd)
   109d4:	fe842783          	lw	a5,-24(s0)
   109d8:	08078263          	beqz	a5,10a5c <read+0xd8>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   109dc:	fe842783          	lw	a5,-24(s0)
   109e0:	0087a783          	lw	a5,8(a5)
   109e4:	0037f713          	andi	a4,a5,3
   109e8:	00100793          	li	a5,1
   109ec:	06f70063          	beq	a4,a5,10a4c <read+0xc8>
        (fd->dev->read))
   109f0:	fe842783          	lw	a5,-24(s0)
   109f4:	0007a783          	lw	a5,0(a5)
   109f8:	0147a783          	lw	a5,20(a5)
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   109fc:	04078863          	beqz	a5,10a4c <read+0xc8>
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   10a00:	fe842783          	lw	a5,-24(s0)
   10a04:	0007a783          	lw	a5,0(a5)
   10a08:	0147a783          	lw	a5,20(a5)
   10a0c:	fd442703          	lw	a4,-44(s0)
   10a10:	00070613          	mv	a2,a4
   10a14:	fd842583          	lw	a1,-40(s0)
   10a18:	fe842503          	lw	a0,-24(s0)
   10a1c:	000780e7          	jalr	a5
   10a20:	fea42623          	sw	a0,-20(s0)
   10a24:	fec42783          	lw	a5,-20(s0)
   10a28:	0007de63          	bgez	a5,10a44 <read+0xc0>
        {
          ALT_ERRNO = -rval;
   10a2c:	fec42783          	lw	a5,-20(s0)
   10a30:	40f00733          	neg	a4,a5
   10a34:	000167b7          	lui	a5,0x16
   10a38:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
          return -1;
   10a3c:	fff00793          	li	a5,-1
   10a40:	02c0006f          	j	10a6c <read+0xe8>
        }
        return rval;
   10a44:	fec42783          	lw	a5,-20(s0)
   10a48:	0240006f          	j	10a6c <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
   10a4c:	000167b7          	lui	a5,0x16
   10a50:	00d00713          	li	a4,13
   10a54:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
   10a58:	0100006f          	j	10a68 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   10a5c:	000167b7          	lui	a5,0x16
   10a60:	05100713          	li	a4,81
   10a64:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
  }
  return -1;
   10a68:	fff00793          	li	a5,-1
}
   10a6c:	00078513          	mv	a0,a5
   10a70:	02c12083          	lw	ra,44(sp)
   10a74:	02812403          	lw	s0,40(sp)
   10a78:	03010113          	addi	sp,sp,48
   10a7c:	00008067          	ret

00010a80 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   10a80:	fe010113          	addi	sp,sp,-32
   10a84:	00812e23          	sw	s0,28(sp)
   10a88:	02010413          	addi	s0,sp,32
   10a8c:	fea42623          	sw	a0,-20(s0)
  if (fd > 2)
   10a90:	fec42703          	lw	a4,-20(s0)
   10a94:	00200793          	li	a5,2
   10a98:	04e7d663          	bge	a5,a4,10ae4 <alt_release_fd+0x64>
  {
    alt_fd_list[fd].fd_flags = 0;
   10a9c:	000147b7          	lui	a5,0x14
   10aa0:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   10aa4:	fec42703          	lw	a4,-20(s0)
   10aa8:	00070793          	mv	a5,a4
   10aac:	00179793          	slli	a5,a5,0x1
   10ab0:	00e787b3          	add	a5,a5,a4
   10ab4:	00279793          	slli	a5,a5,0x2
   10ab8:	00f687b3          	add	a5,a3,a5
   10abc:	0007a423          	sw	zero,8(a5)
    alt_fd_list[fd].dev      = 0;
   10ac0:	000147b7          	lui	a5,0x14
   10ac4:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   10ac8:	fec42703          	lw	a4,-20(s0)
   10acc:	00070793          	mv	a5,a4
   10ad0:	00179793          	slli	a5,a5,0x1
   10ad4:	00e787b3          	add	a5,a5,a4
   10ad8:	00279793          	slli	a5,a5,0x2
   10adc:	00f687b3          	add	a5,a3,a5
   10ae0:	0007a023          	sw	zero,0(a5)
  }
}
   10ae4:	00000013          	nop
   10ae8:	01c12403          	lw	s0,28(sp)
   10aec:	02010113          	addi	sp,sp,32
   10af0:	00008067          	ret

00010af4 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
   10af4:	fe010113          	addi	sp,sp,-32
   10af8:	00112e23          	sw	ra,28(sp)
   10afc:	00812c23          	sw	s0,24(sp)
   10b00:	02010413          	addi	s0,sp,32
   10b04:	fea42623          	sw	a0,-20(s0)
  return alt_busy_sleep(us);
   10b08:	fec42503          	lw	a0,-20(s0)
   10b0c:	70c010ef          	jal	ra,12218 <alt_busy_sleep>
   10b10:	00050793          	mv	a5,a0
}
   10b14:	00078513          	mv	a0,a5
   10b18:	01c12083          	lw	ra,28(sp)
   10b1c:	01812403          	lw	s0,24(sp)
   10b20:	02010113          	addi	sp,sp,32
   10b24:	00008067          	ret

00010b28 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   10b28:	fd010113          	addi	sp,sp,-48
   10b2c:	02112623          	sw	ra,44(sp)
   10b30:	02812423          	sw	s0,40(sp)
   10b34:	03010413          	addi	s0,sp,48
   10b38:	fca42e23          	sw	a0,-36(s0)
   10b3c:	fcb42c23          	sw	a1,-40(s0)
   10b40:	fcc42a23          	sw	a2,-44(s0)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   10b44:	fdc42783          	lw	a5,-36(s0)
   10b48:	0207c463          	bltz	a5,10b70 <write+0x48>
   10b4c:	fdc42703          	lw	a4,-36(s0)
   10b50:	00070793          	mv	a5,a4
   10b54:	00179793          	slli	a5,a5,0x1
   10b58:	00e787b3          	add	a5,a5,a4
   10b5c:	00279793          	slli	a5,a5,0x2
   10b60:	00014737          	lui	a4,0x14
   10b64:	63c70713          	addi	a4,a4,1596 # 1463c <alt_fd_list>
   10b68:	00e787b3          	add	a5,a5,a4
   10b6c:	0080006f          	j	10b74 <write+0x4c>
   10b70:	00000793          	li	a5,0
   10b74:	fef42423          	sw	a5,-24(s0)
  
  if (fd)
   10b78:	fe842783          	lw	a5,-24(s0)
   10b7c:	08078063          	beqz	a5,10bfc <write+0xd4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   10b80:	fe842783          	lw	a5,-24(s0)
   10b84:	0087a783          	lw	a5,8(a5)
   10b88:	0037f793          	andi	a5,a5,3
   10b8c:	06078063          	beqz	a5,10bec <write+0xc4>
   10b90:	fe842783          	lw	a5,-24(s0)
   10b94:	0007a783          	lw	a5,0(a5)
   10b98:	0187a783          	lw	a5,24(a5)
   10b9c:	04078863          	beqz	a5,10bec <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   10ba0:	fe842783          	lw	a5,-24(s0)
   10ba4:	0007a783          	lw	a5,0(a5)
   10ba8:	0187a783          	lw	a5,24(a5)
   10bac:	fd442703          	lw	a4,-44(s0)
   10bb0:	00070613          	mv	a2,a4
   10bb4:	fd842583          	lw	a1,-40(s0)
   10bb8:	fe842503          	lw	a0,-24(s0)
   10bbc:	000780e7          	jalr	a5
   10bc0:	fea42623          	sw	a0,-20(s0)
   10bc4:	fec42783          	lw	a5,-20(s0)
   10bc8:	0007de63          	bgez	a5,10be4 <write+0xbc>
      {
        ALT_ERRNO = -rval;
   10bcc:	fec42783          	lw	a5,-20(s0)
   10bd0:	40f00733          	neg	a4,a5
   10bd4:	000167b7          	lui	a5,0x16
   10bd8:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
        return -1;
   10bdc:	fff00793          	li	a5,-1
   10be0:	02c0006f          	j	10c0c <write+0xe4>
      }
      return rval;
   10be4:	fec42783          	lw	a5,-20(s0)
   10be8:	0240006f          	j	10c0c <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
   10bec:	000167b7          	lui	a5,0x16
   10bf0:	00d00713          	li	a4,13
   10bf4:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
   10bf8:	0100006f          	j	10c08 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   10bfc:	000167b7          	lui	a5,0x16
   10c00:	05100713          	li	a4,81
   10c04:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
  }
  return -1;
   10c08:	fff00793          	li	a5,-1
}
   10c0c:	00078513          	mv	a0,a5
   10c10:	02c12083          	lw	ra,44(sp)
   10c14:	02812403          	lw	s0,40(sp)
   10c18:	03010113          	addi	sp,sp,48
   10c1c:	00008067          	ret

00010c20 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   10c20:	fe010113          	addi	sp,sp,-32
   10c24:	00112e23          	sw	ra,28(sp)
   10c28:	00812c23          	sw	s0,24(sp)
   10c2c:	02010413          	addi	s0,sp,32
   10c30:	fea42623          	sw	a0,-20(s0)
    INTEL_NIOSV_M_IRQ_INIT ( NIOSV_M_CPU, NIOSV_M_CPU);
   10c34:	76d010ef          	jal	ra,12ba0 <intel_niosv_irq_init>
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, NIOSV_MSTATUS_MIE_MASK);
   10c38:	00800793          	li	a5,8
   10c3c:	3007a073          	csrs	mstatus,a5
}
   10c40:	00000013          	nop
    alt_irq_cpu_enable_interrupts();
}
   10c44:	00000013          	nop
   10c48:	01c12083          	lw	ra,28(sp)
   10c4c:	01812403          	lw	s0,24(sp)
   10c50:	02010113          	addi	sp,sp,32
   10c54:	00008067          	ret

00010c58 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   10c58:	fe010113          	addi	sp,sp,-32
   10c5c:	00112e23          	sw	ra,28(sp)
   10c60:	00812c23          	sw	s0,24(sp)
   10c64:	02010413          	addi	s0,sp,32
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_DBG, JTAG_UART_DBG);
   10c68:	00000613          	li	a2,0
   10c6c:	00000593          	li	a1,0
   10c70:	000137b7          	lui	a5,0x13
   10c74:	51878513          	addi	a0,a5,1304 # 13518 <JTAG_UART_DBG+0x28>
   10c78:	214000ef          	jal	ra,10e8c <altera_avalon_jtag_uart_init>
   10c7c:	000137b7          	lui	a5,0x13
   10c80:	4f078513          	addi	a0,a5,1264 # 134f0 <JTAG_UART_DBG>
   10c84:	73c010ef          	jal	ra,123c0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SOC_SYSID, SOC_SYSID);
   10c88:	00000013          	nop
    ALTERA_AVALON_UART_INIT ( UART_SERIAL_COM, UART_SERIAL_COM);
   10c8c:	00100613          	li	a2,1
   10c90:	00000593          	li	a1,0
   10c94:	000147b7          	lui	a5,0x14
   10c98:	57878513          	addi	a0,a5,1400 # 14578 <UART_SERIAL_COM+0x28>
   10c9c:	495000ef          	jal	ra,11930 <altera_avalon_uart_init>
   10ca0:	000147b7          	lui	a5,0x14
   10ca4:	55078513          	addi	a0,a5,1360 # 14550 <UART_SERIAL_COM>
   10ca8:	718010ef          	jal	ra,123c0 <alt_dev_reg>
   10cac:	3e800793          	li	a5,1000
   10cb0:	fef42623          	sw	a5,-20(s0)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   10cb4:	000167b7          	lui	a5,0x16
   10cb8:	b707a783          	lw	a5,-1168(a5) # 15b70 <_alt_tick_rate>
   10cbc:	00079a63          	bnez	a5,10cd0 <alt_sys_init+0x78>
  {
    _alt_tick_rate = nticks;
   10cc0:	000167b7          	lui	a5,0x16
   10cc4:	fec42703          	lw	a4,-20(s0)
   10cc8:	b6e7a823          	sw	a4,-1168(a5) # 15b70 <_alt_tick_rate>
    return 0;
   10ccc:	0080006f          	j	10cd4 <alt_sys_init+0x7c>
  }
  else
  {
    return -1;
   10cd0:	00000013          	nop
   10cd4:	000137b7          	lui	a5,0x13
   10cd8:	dcc78793          	addi	a5,a5,-564 # 12dcc <alt_niosv_timer_sc_isr>
   10cdc:	fef42423          	sw	a5,-24(s0)
alt_u64 alt_niosv_mtimecmp_get();
void alt_niosv_mtimecmp_interrupt_init();
extern alt_niosv_timer_isr_t alt_niosv_timer_interrupt_handler;

static ALT_INLINE void ALT_ALWAYS_INLINE alt_niosv_register_mtimecmp_interrupt_handle(alt_niosv_timer_isr_t handle) {
    alt_niosv_timer_interrupt_handler = handle;
   10ce0:	000167b7          	lui	a5,0x16
   10ce4:	fe842703          	lw	a4,-24(s0)
   10ce8:	b4e7ae23          	sw	a4,-1188(a5) # 15b5c <alt_niosv_timer_interrupt_handler>
}
   10cec:	00000013          	nop
    INTEL_NIOSV_M_INIT ( NIOSV_M_CPU, NIOSV_M_CPU);
   10cf0:	188020ef          	jal	ra,12e78 <alt_niosv_mtimecmp_interrupt_init>
   10cf4:	00000613          	li	a2,0
   10cf8:	00000593          	li	a1,0
   10cfc:	00000513          	li	a0,0
   10d00:	0cc020ef          	jal	ra,12dcc <alt_niosv_timer_sc_isr>
}
   10d04:	00000013          	nop
   10d08:	01c12083          	lw	ra,28(sp)
   10d0c:	01812403          	lw	s0,24(sp)
   10d10:	02010113          	addi	sp,sp,32
   10d14:	00008067          	ret

00010d18 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   10d18:	fd010113          	addi	sp,sp,-48
   10d1c:	02112623          	sw	ra,44(sp)
   10d20:	02812423          	sw	s0,40(sp)
   10d24:	03010413          	addi	s0,sp,48
   10d28:	fca42e23          	sw	a0,-36(s0)
   10d2c:	fcb42c23          	sw	a1,-40(s0)
   10d30:	fcc42a23          	sw	a2,-44(s0)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   10d34:	fdc42783          	lw	a5,-36(s0)
   10d38:	0007a783          	lw	a5,0(a5)
   10d3c:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   10d40:	fec42783          	lw	a5,-20(s0)
   10d44:	02878713          	addi	a4,a5,40
   10d48:	fdc42783          	lw	a5,-36(s0)
   10d4c:	0087a783          	lw	a5,8(a5)
   10d50:	00078693          	mv	a3,a5
   10d54:	fd442603          	lw	a2,-44(s0)
   10d58:	fd842583          	lw	a1,-40(s0)
   10d5c:	00070513          	mv	a0,a4
   10d60:	64c000ef          	jal	ra,113ac <altera_avalon_jtag_uart_read>
   10d64:	00050793          	mv	a5,a0
      fd->fd_flags);
}
   10d68:	00078513          	mv	a0,a5
   10d6c:	02c12083          	lw	ra,44(sp)
   10d70:	02812403          	lw	s0,40(sp)
   10d74:	03010113          	addi	sp,sp,48
   10d78:	00008067          	ret

00010d7c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   10d7c:	fd010113          	addi	sp,sp,-48
   10d80:	02112623          	sw	ra,44(sp)
   10d84:	02812423          	sw	s0,40(sp)
   10d88:	03010413          	addi	s0,sp,48
   10d8c:	fca42e23          	sw	a0,-36(s0)
   10d90:	fcb42c23          	sw	a1,-40(s0)
   10d94:	fcc42a23          	sw	a2,-44(s0)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   10d98:	fdc42783          	lw	a5,-36(s0)
   10d9c:	0007a783          	lw	a5,0(a5)
   10da0:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   10da4:	fec42783          	lw	a5,-20(s0)
   10da8:	02878713          	addi	a4,a5,40
   10dac:	fdc42783          	lw	a5,-36(s0)
   10db0:	0087a783          	lw	a5,8(a5)
   10db4:	00078693          	mv	a3,a5
   10db8:	fd442603          	lw	a2,-44(s0)
   10dbc:	fd842583          	lw	a1,-40(s0)
   10dc0:	00070513          	mv	a0,a4
   10dc4:	015000ef          	jal	ra,115d8 <altera_avalon_jtag_uart_write>
   10dc8:	00050793          	mv	a5,a0
      fd->fd_flags);
}
   10dcc:	00078513          	mv	a0,a5
   10dd0:	02c12083          	lw	ra,44(sp)
   10dd4:	02812403          	lw	s0,40(sp)
   10dd8:	03010113          	addi	sp,sp,48
   10ddc:	00008067          	ret

00010de0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   10de0:	fd010113          	addi	sp,sp,-48
   10de4:	02112623          	sw	ra,44(sp)
   10de8:	02812423          	sw	s0,40(sp)
   10dec:	03010413          	addi	s0,sp,48
   10df0:	fca42e23          	sw	a0,-36(s0)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   10df4:	fdc42783          	lw	a5,-36(s0)
   10df8:	0007a783          	lw	a5,0(a5)
   10dfc:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   10e00:	fec42783          	lw	a5,-20(s0)
   10e04:	02878713          	addi	a4,a5,40
   10e08:	fdc42783          	lw	a5,-36(s0)
   10e0c:	0087a783          	lw	a5,8(a5)
   10e10:	00078593          	mv	a1,a5
   10e14:	00070513          	mv	a0,a4
   10e18:	428000ef          	jal	ra,11240 <altera_avalon_jtag_uart_close>
   10e1c:	00050793          	mv	a5,a0
}
   10e20:	00078513          	mv	a0,a5
   10e24:	02c12083          	lw	ra,44(sp)
   10e28:	02812403          	lw	s0,40(sp)
   10e2c:	03010113          	addi	sp,sp,48
   10e30:	00008067          	ret

00010e34 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   10e34:	fd010113          	addi	sp,sp,-48
   10e38:	02112623          	sw	ra,44(sp)
   10e3c:	02812423          	sw	s0,40(sp)
   10e40:	03010413          	addi	s0,sp,48
   10e44:	fca42e23          	sw	a0,-36(s0)
   10e48:	fcb42c23          	sw	a1,-40(s0)
   10e4c:	fcc42a23          	sw	a2,-44(s0)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   10e50:	fdc42783          	lw	a5,-36(s0)
   10e54:	0007a783          	lw	a5,0(a5)
   10e58:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   10e5c:	fec42783          	lw	a5,-20(s0)
   10e60:	02878793          	addi	a5,a5,40
   10e64:	fd442603          	lw	a2,-44(s0)
   10e68:	fd842583          	lw	a1,-40(s0)
   10e6c:	00078513          	mv	a0,a5
   10e70:	43c000ef          	jal	ra,112ac <altera_avalon_jtag_uart_ioctl>
   10e74:	00050793          	mv	a5,a0
}
   10e78:	00078513          	mv	a0,a5
   10e7c:	02c12083          	lw	ra,44(sp)
   10e80:	02812403          	lw	s0,40(sp)
   10e84:	03010113          	addi	sp,sp,48
   10e88:	00008067          	ret

00010e8c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   10e8c:	fd010113          	addi	sp,sp,-48
   10e90:	02112623          	sw	ra,44(sp)
   10e94:	02812423          	sw	s0,40(sp)
   10e98:	03010413          	addi	s0,sp,48
   10e9c:	fca42e23          	sw	a0,-36(s0)
   10ea0:	fcb42c23          	sw	a1,-40(s0)
   10ea4:	fcc42a23          	sw	a2,-44(s0)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   10ea8:	fdc42783          	lw	a5,-36(s0)
   10eac:	00100713          	li	a4,1
   10eb0:	02e7a023          	sw	a4,32(a5)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   10eb4:	fdc42783          	lw	a5,-36(s0)
   10eb8:	0207a783          	lw	a5,32(a5)
   10ebc:	fef42623          	sw	a5,-20(s0)
   10ec0:	fdc42783          	lw	a5,-36(s0)
   10ec4:	0007a783          	lw	a5,0(a5)
   10ec8:	00478793          	addi	a5,a5,4
   10ecc:	00078713          	mv	a4,a5
   10ed0:	fec42783          	lw	a5,-20(s0)
   10ed4:	00f72023          	sw	a5,0(a4)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   10ed8:	fd842503          	lw	a0,-40(s0)
   10edc:	fd442583          	lw	a1,-44(s0)
   10ee0:	00000713          	li	a4,0
   10ee4:	fdc42683          	lw	a3,-36(s0)
   10ee8:	000117b7          	lui	a5,0x11
   10eec:	f4c78613          	addi	a2,a5,-180 # 10f4c <altera_avalon_jtag_uart_irq>
   10ef0:	0e9010ef          	jal	ra,127d8 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   10ef4:	fdc42783          	lw	a5,-36(s0)
   10ef8:	0207a223          	sw	zero,36(a5)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   10efc:	fdc42783          	lw	a5,-36(s0)
   10f00:	00878713          	addi	a4,a5,8
  return _alt_tick_rate;
   10f04:	000167b7          	lui	a5,0x16
   10f08:	b707a583          	lw	a1,-1168(a5) # 15b70 <_alt_tick_rate>
   10f0c:	fdc42683          	lw	a3,-36(s0)
   10f10:	000117b7          	lui	a5,0x11
   10f14:	18478613          	addi	a2,a5,388 # 11184 <altera_avalon_jtag_uart_timeout>
   10f18:	00070513          	mv	a0,a4
   10f1c:	190010ef          	jal	ra,120ac <alt_alarm_start>
   10f20:	00050793          	mv	a5,a0
   10f24:	0007da63          	bgez	a5,10f38 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   10f28:	fdc42783          	lw	a5,-36(s0)
   10f2c:	80000737          	lui	a4,0x80000
   10f30:	fff74713          	not	a4,a4
   10f34:	00e7a223          	sw	a4,4(a5)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   10f38:	00000013          	nop
   10f3c:	02c12083          	lw	ra,44(sp)
   10f40:	02812403          	lw	s0,40(sp)
   10f44:	03010113          	addi	sp,sp,48
   10f48:	00008067          	ret

00010f4c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   10f4c:	fa010113          	addi	sp,sp,-96
   10f50:	04812e23          	sw	s0,92(sp)
   10f54:	06010413          	addi	s0,sp,96
   10f58:	faa42623          	sw	a0,-84(s0)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   10f5c:	fac42783          	lw	a5,-84(s0)
   10f60:	fcf42223          	sw	a5,-60(s0)
  unsigned int base = sp->base;
   10f64:	fc442783          	lw	a5,-60(s0)
   10f68:	0007a783          	lw	a5,0(a5)
   10f6c:	fcf42423          	sw	a5,-56(s0)
  unsigned int postflag=0;
   10f70:	fa042c23          	sw	zero,-72(s0)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   10f74:	fc842783          	lw	a5,-56(s0)
   10f78:	00478793          	addi	a5,a5,4
   10f7c:	0007a783          	lw	a5,0(a5)
   10f80:	fcf42623          	sw	a5,-52(s0)
   10f84:	fcc42783          	lw	a5,-52(s0)
   10f88:	fcf42823          	sw	a5,-48(s0)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   10f8c:	fd042783          	lw	a5,-48(s0)
   10f90:	3007f793          	andi	a5,a5,768
   10f94:	1c078e63          	beqz	a5,11170 <altera_avalon_jtag_uart_irq+0x224>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   10f98:	fd042783          	lw	a5,-48(s0)
   10f9c:	1007f793          	andi	a5,a5,256
   10fa0:	0e078663          	beqz	a5,1108c <altera_avalon_jtag_uart_irq+0x140>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   10fa4:	000107b7          	lui	a5,0x10
   10fa8:	faf42e23          	sw	a5,-68(s0)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   10fac:	fc442783          	lw	a5,-60(s0)
   10fb0:	0287a783          	lw	a5,40(a5) # 10028 <__flash_exceptions_start+0x8>
   10fb4:	00178793          	addi	a5,a5,1
   10fb8:	7ff7f793          	andi	a5,a5,2047
   10fbc:	fcf42a23          	sw	a5,-44(s0)
        if (next == sp->rx_out)
   10fc0:	fc442783          	lw	a5,-60(s0)
   10fc4:	02c7a783          	lw	a5,44(a5)
   10fc8:	fd442703          	lw	a4,-44(s0)
   10fcc:	06f70263          	beq	a4,a5,11030 <altera_avalon_jtag_uart_irq+0xe4>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   10fd0:	fc842783          	lw	a5,-56(s0)
   10fd4:	0007a783          	lw	a5,0(a5)
   10fd8:	fcf42c23          	sw	a5,-40(s0)
   10fdc:	fd842783          	lw	a5,-40(s0)
   10fe0:	faf42e23          	sw	a5,-68(s0)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   10fe4:	fbc42703          	lw	a4,-68(s0)
   10fe8:	000087b7          	lui	a5,0x8
   10fec:	00f777b3          	and	a5,a4,a5
   10ff0:	04078463          	beqz	a5,11038 <altera_avalon_jtag_uart_irq+0xec>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   10ff4:	fc442783          	lw	a5,-60(s0)
   10ff8:	0287a783          	lw	a5,40(a5) # 8028 <_sig_func+0x8028>
   10ffc:	fbc42703          	lw	a4,-68(s0)
   11000:	0ff77713          	zext.b	a4,a4
   11004:	fc442683          	lw	a3,-60(s0)
   11008:	00f687b3          	add	a5,a3,a5
   1100c:	02e78c23          	sb	a4,56(a5)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   11010:	fc442783          	lw	a5,-60(s0)
   11014:	0287a783          	lw	a5,40(a5)
   11018:	00178793          	addi	a5,a5,1
   1101c:	7ff7f713          	andi	a4,a5,2047
   11020:	fc442783          	lw	a5,-60(s0)
   11024:	02e7a423          	sw	a4,40(a5)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   11028:	00000013          	nop
      {
   1102c:	f81ff06f          	j	10fac <altera_avalon_jtag_uart_irq+0x60>
          break;
   11030:	00000013          	nop
   11034:	0080006f          	j	1103c <altera_avalon_jtag_uart_irq+0xf0>
          break;
   11038:	00000013          	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, ALT_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   1103c:	fbc42703          	lw	a4,-68(s0)
   11040:	000107b7          	lui	a5,0x10
   11044:	04f76463          	bltu	a4,a5,1108c <altera_avalon_jtag_uart_irq+0x140>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   11048:	fc442783          	lw	a5,-60(s0)
   1104c:	0207a783          	lw	a5,32(a5) # 10020 <__flash_exceptions_start>
   11050:	ffe7f713          	andi	a4,a5,-2
   11054:	fc442783          	lw	a5,-60(s0)
   11058:	02e7a023          	sw	a4,32(a5)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   1105c:	fc442783          	lw	a5,-60(s0)
   11060:	0207a783          	lw	a5,32(a5)
   11064:	fcf42e23          	sw	a5,-36(s0)
   11068:	fc842783          	lw	a5,-56(s0)
   1106c:	00478793          	addi	a5,a5,4
   11070:	00078713          	mv	a4,a5
   11074:	fdc42783          	lw	a5,-36(s0)
   11078:	00f72023          	sw	a5,0(a4) # 80000000 <__alt_data_end+0x7ffe4000>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   1107c:	fc842783          	lw	a5,-56(s0)
   11080:	00478793          	addi	a5,a5,4
   11084:	0007a783          	lw	a5,0(a5)
   11088:	fef42023          	sw	a5,-32(s0)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   1108c:	fd042783          	lw	a5,-48(s0)
   11090:	2007f793          	andi	a5,a5,512
   11094:	ee0780e3          	beqz	a5,10f74 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   11098:	fd042783          	lw	a5,-48(s0)
   1109c:	0107d793          	srli	a5,a5,0x10
   110a0:	fcf42023          	sw	a5,-64(s0)

      while (space > 0 && sp->tx_out != sp->tx_in)
   110a4:	05c0006f          	j	11100 <altera_avalon_jtag_uart_irq+0x1b4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   110a8:	fc442783          	lw	a5,-60(s0)
   110ac:	0347a783          	lw	a5,52(a5)
   110b0:	fc442703          	lw	a4,-60(s0)
   110b4:	00f707b3          	add	a5,a4,a5
   110b8:	00001737          	lui	a4,0x1
   110bc:	00f707b3          	add	a5,a4,a5
   110c0:	8387c783          	lbu	a5,-1992(a5)
   110c4:	fef42223          	sw	a5,-28(s0)
   110c8:	fc842783          	lw	a5,-56(s0)
   110cc:	fe442703          	lw	a4,-28(s0)
   110d0:	00e7a023          	sw	a4,0(a5)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   110d4:	fc442783          	lw	a5,-60(s0)
   110d8:	0347a783          	lw	a5,52(a5)
   110dc:	00178793          	addi	a5,a5,1
   110e0:	7ff7f713          	andi	a4,a5,2047
   110e4:	fc442783          	lw	a5,-60(s0)
   110e8:	02e7aa23          	sw	a4,52(a5)
        
        /* indicate that the ALT_FLAG_POST routine must be called */
        postflag=1;
   110ec:	00100793          	li	a5,1
   110f0:	faf42c23          	sw	a5,-72(s0)

        space--;
   110f4:	fc042783          	lw	a5,-64(s0)
   110f8:	fff78793          	addi	a5,a5,-1
   110fc:	fcf42023          	sw	a5,-64(s0)
      while (space > 0 && sp->tx_out != sp->tx_in)
   11100:	fc042783          	lw	a5,-64(s0)
   11104:	00078c63          	beqz	a5,1111c <altera_avalon_jtag_uart_irq+0x1d0>
   11108:	fc442783          	lw	a5,-60(s0)
   1110c:	0347a703          	lw	a4,52(a5)
   11110:	fc442783          	lw	a5,-60(s0)
   11114:	0307a783          	lw	a5,48(a5)
   11118:	f8f718e3          	bne	a4,a5,110a8 <altera_avalon_jtag_uart_irq+0x15c>
      {
        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, ALT_FLAG_SET);
      }

      if (space > 0)
   1111c:	fc042783          	lw	a5,-64(s0)
   11120:	e4078ae3          	beqz	a5,10f74 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   11124:	fc442783          	lw	a5,-60(s0)
   11128:	0207a783          	lw	a5,32(a5)
   1112c:	ffd7f713          	andi	a4,a5,-3
   11130:	fc442783          	lw	a5,-60(s0)
   11134:	02e7a023          	sw	a4,32(a5)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   11138:	fc442783          	lw	a5,-60(s0)
   1113c:	0207a783          	lw	a5,32(a5)
   11140:	fef42423          	sw	a5,-24(s0)
   11144:	fc442783          	lw	a5,-60(s0)
   11148:	0007a783          	lw	a5,0(a5)
   1114c:	00478793          	addi	a5,a5,4
   11150:	00078713          	mv	a4,a5
   11154:	fe842783          	lw	a5,-24(s0)
   11158:	00f72023          	sw	a5,0(a4) # 1000 <_sig_func+0x1000>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   1115c:	fc842783          	lw	a5,-56(s0)
   11160:	00478793          	addi	a5,a5,4
   11164:	0007a783          	lw	a5,0(a5)
   11168:	fef42623          	sw	a5,-20(s0)
  {
   1116c:	e09ff06f          	j	10f74 <altera_avalon_jtag_uart_irq+0x28>
      break;
   11170:	00000013          	nop
      }
    }
  }
}
   11174:	00000013          	nop
   11178:	05c12403          	lw	s0,92(sp)
   1117c:	06010113          	addi	sp,sp,96
   11180:	00008067          	ret

00011184 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   11184:	fd010113          	addi	sp,sp,-48
   11188:	02812623          	sw	s0,44(sp)
   1118c:	03010413          	addi	s0,sp,48
   11190:	fca42e23          	sw	a0,-36(s0)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   11194:	fdc42783          	lw	a5,-36(s0)
   11198:	fef42023          	sw	a5,-32(s0)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   1119c:	fe042783          	lw	a5,-32(s0)
   111a0:	0007a783          	lw	a5,0(a5)
   111a4:	00478793          	addi	a5,a5,4
   111a8:	0007a783          	lw	a5,0(a5)
   111ac:	fef42223          	sw	a5,-28(s0)
   111b0:	fe442783          	lw	a5,-28(s0)
   111b4:	fef42423          	sw	a5,-24(s0)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   111b8:	fe842783          	lw	a5,-24(s0)
   111bc:	4007f793          	andi	a5,a5,1024
   111c0:	02078c63          	beqz	a5,111f8 <altera_avalon_jtag_uart_timeout+0x74>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   111c4:	fe042783          	lw	a5,-32(s0)
   111c8:	0207a783          	lw	a5,32(a5)
   111cc:	4007e793          	ori	a5,a5,1024
   111d0:	fef42623          	sw	a5,-20(s0)
   111d4:	fe042783          	lw	a5,-32(s0)
   111d8:	0007a783          	lw	a5,0(a5)
   111dc:	00478793          	addi	a5,a5,4
   111e0:	00078713          	mv	a4,a5
   111e4:	fec42783          	lw	a5,-20(s0)
   111e8:	00f72023          	sw	a5,0(a4)
    sp->host_inactive = 0;
   111ec:	fe042783          	lw	a5,-32(s0)
   111f0:	0207a223          	sw	zero,36(a5)
   111f4:	0340006f          	j	11228 <altera_avalon_jtag_uart_timeout+0xa4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   111f8:	fe042783          	lw	a5,-32(s0)
   111fc:	0247a703          	lw	a4,36(a5)
   11200:	800007b7          	lui	a5,0x80000
   11204:	ffc7c793          	xori	a5,a5,-4
   11208:	02e7e063          	bltu	a5,a4,11228 <altera_avalon_jtag_uart_timeout+0xa4>
    sp->host_inactive++;
   1120c:	fe042783          	lw	a5,-32(s0)
   11210:	0247a783          	lw	a5,36(a5) # 80000024 <__alt_data_end+0x7ffe4024>
   11214:	00178713          	addi	a4,a5,1
   11218:	fe042783          	lw	a5,-32(s0)
   1121c:	02e7a223          	sw	a4,36(a5)
    
    if (sp->host_inactive >= sp->timeout) {
   11220:	fe042783          	lw	a5,-32(s0)
   11224:	0247a783          	lw	a5,36(a5)
   11228:	000167b7          	lui	a5,0x16
   1122c:	b707a783          	lw	a5,-1168(a5) # 15b70 <_alt_tick_rate>
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, ALT_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   11230:	00078513          	mv	a0,a5
   11234:	02c12403          	lw	s0,44(sp)
   11238:	03010113          	addi	sp,sp,48
   1123c:	00008067          	ret

00011240 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   11240:	fe010113          	addi	sp,sp,-32
   11244:	00812e23          	sw	s0,28(sp)
   11248:	02010413          	addi	s0,sp,32
   1124c:	fea42623          	sw	a0,-20(s0)
   11250:	feb42423          	sw	a1,-24(s0)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   11254:	01c0006f          	j	11270 <altera_avalon_jtag_uart_close+0x30>
    if (flags & O_NONBLOCK) {
   11258:	fe842703          	lw	a4,-24(s0)
   1125c:	000047b7          	lui	a5,0x4
   11260:	00f777b3          	and	a5,a4,a5
   11264:	00078663          	beqz	a5,11270 <altera_avalon_jtag_uart_close+0x30>
      return -EWOULDBLOCK; 
   11268:	ff500793          	li	a5,-11
   1126c:	0300006f          	j	1129c <altera_avalon_jtag_uart_close+0x5c>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   11270:	fec42783          	lw	a5,-20(s0)
   11274:	0347a703          	lw	a4,52(a5) # 4034 <_sig_func+0x4034>
   11278:	fec42783          	lw	a5,-20(s0)
   1127c:	0307a783          	lw	a5,48(a5)
   11280:	00f70c63          	beq	a4,a5,11298 <altera_avalon_jtag_uart_close+0x58>
   11284:	fec42783          	lw	a5,-20(s0)
   11288:	0247a703          	lw	a4,36(a5)
   1128c:	fec42783          	lw	a5,-20(s0)
   11290:	0047a783          	lw	a5,4(a5)
   11294:	fcf762e3          	bltu	a4,a5,11258 <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
   11298:	00000793          	li	a5,0
}
   1129c:	00078513          	mv	a0,a5
   112a0:	01c12403          	lw	s0,28(sp)
   112a4:	02010113          	addi	sp,sp,32
   112a8:	00008067          	ret

000112ac <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   112ac:	fd010113          	addi	sp,sp,-48
   112b0:	02812623          	sw	s0,44(sp)
   112b4:	03010413          	addi	s0,sp,48
   112b8:	fca42e23          	sw	a0,-36(s0)
   112bc:	fcb42c23          	sw	a1,-40(s0)
   112c0:	fcc42a23          	sw	a2,-44(s0)
  int rc = -ENOTTY;
   112c4:	fe700793          	li	a5,-25
   112c8:	fef42423          	sw	a5,-24(s0)

  switch (req)
   112cc:	fd842703          	lw	a4,-40(s0)
   112d0:	000077b7          	lui	a5,0x7
   112d4:	a0178793          	addi	a5,a5,-1535 # 6a01 <_sig_func+0x6a01>
   112d8:	00f70c63          	beq	a4,a5,112f0 <altera_avalon_jtag_uart_ioctl+0x44>
   112dc:	fd842703          	lw	a4,-40(s0)
   112e0:	000077b7          	lui	a5,0x7
   112e4:	a0278793          	addi	a5,a5,-1534 # 6a02 <_sig_func+0x6a02>
   112e8:	06f70263          	beq	a4,a5,1134c <altera_avalon_jtag_uart_ioctl+0xa0>
      rc = 0;
    }
    break;

  default:
    break;
   112ec:	0ac0006f          	j	11398 <altera_avalon_jtag_uart_ioctl+0xec>
    if (sp->timeout != INT_MAX)
   112f0:	fdc42783          	lw	a5,-36(s0)
   112f4:	0047a703          	lw	a4,4(a5)
   112f8:	800007b7          	lui	a5,0x80000
   112fc:	fff7c793          	not	a5,a5
   11300:	08f70663          	beq	a4,a5,1138c <altera_avalon_jtag_uart_ioctl+0xe0>
      int timeout = *((int *)arg);
   11304:	fd442783          	lw	a5,-44(s0)
   11308:	0007a783          	lw	a5,0(a5) # 80000000 <__alt_data_end+0x7ffe4000>
   1130c:	fef42623          	sw	a5,-20(s0)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   11310:	fec42703          	lw	a4,-20(s0)
   11314:	00100793          	li	a5,1
   11318:	00e7de63          	bge	a5,a4,11334 <altera_avalon_jtag_uart_ioctl+0x88>
   1131c:	fec42703          	lw	a4,-20(s0)
   11320:	800007b7          	lui	a5,0x80000
   11324:	fff7c793          	not	a5,a5
   11328:	00f70663          	beq	a4,a5,11334 <altera_avalon_jtag_uart_ioctl+0x88>
   1132c:	fec42783          	lw	a5,-20(s0)
   11330:	00c0006f          	j	1133c <altera_avalon_jtag_uart_ioctl+0x90>
   11334:	800007b7          	lui	a5,0x80000
   11338:	ffe7c793          	xori	a5,a5,-2
   1133c:	fdc42703          	lw	a4,-36(s0)
   11340:	00f72223          	sw	a5,4(a4)
      rc = 0;
   11344:	fe042423          	sw	zero,-24(s0)
    break;
   11348:	0440006f          	j	1138c <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
   1134c:	fdc42783          	lw	a5,-36(s0)
   11350:	0047a703          	lw	a4,4(a5) # 80000004 <__alt_data_end+0x7ffe4004>
   11354:	800007b7          	lui	a5,0x80000
   11358:	fff7c793          	not	a5,a5
   1135c:	02f70c63          	beq	a4,a5,11394 <altera_avalon_jtag_uart_ioctl+0xe8>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   11360:	fdc42783          	lw	a5,-36(s0)
   11364:	0247a703          	lw	a4,36(a5) # 80000024 <__alt_data_end+0x7ffe4024>
   11368:	fdc42783          	lw	a5,-36(s0)
   1136c:	0047a783          	lw	a5,4(a5)
   11370:	00f737b3          	sltu	a5,a4,a5
   11374:	0ff7f793          	zext.b	a5,a5
   11378:	00078713          	mv	a4,a5
   1137c:	fd442783          	lw	a5,-44(s0)
   11380:	00e7a023          	sw	a4,0(a5)
      rc = 0;
   11384:	fe042423          	sw	zero,-24(s0)
    break;
   11388:	00c0006f          	j	11394 <altera_avalon_jtag_uart_ioctl+0xe8>
    break;
   1138c:	00000013          	nop
   11390:	0080006f          	j	11398 <altera_avalon_jtag_uart_ioctl+0xec>
    break;
   11394:	00000013          	nop
  }

  return rc;
   11398:	fe842783          	lw	a5,-24(s0)
}
   1139c:	00078513          	mv	a0,a5
   113a0:	02c12403          	lw	s0,44(sp)
   113a4:	03010113          	addi	sp,sp,48
   113a8:	00008067          	ret

000113ac <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   113ac:	fc010113          	addi	sp,sp,-64
   113b0:	02112e23          	sw	ra,60(sp)
   113b4:	02812c23          	sw	s0,56(sp)
   113b8:	04010413          	addi	s0,sp,64
   113bc:	fca42623          	sw	a0,-52(s0)
   113c0:	fcb42423          	sw	a1,-56(s0)
   113c4:	fcc42223          	sw	a2,-60(s0)
   113c8:	fcd42023          	sw	a3,-64(s0)
  char * ptr = buffer;
   113cc:	fc842783          	lw	a5,-56(s0)
   113d0:	fcf42823          	sw	a5,-48(s0)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   113d4:	1280006f          	j	114fc <altera_avalon_jtag_uart_read+0x150>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   113d8:	fcc42783          	lw	a5,-52(s0)
   113dc:	0287a783          	lw	a5,40(a5)
   113e0:	fcf42c23          	sw	a5,-40(s0)
      out = sp->rx_out;
   113e4:	fcc42783          	lw	a5,-52(s0)
   113e8:	02c7a783          	lw	a5,44(a5)
   113ec:	fcf42e23          	sw	a5,-36(s0)

      if (in >= out)
   113f0:	fd842703          	lw	a4,-40(s0)
   113f4:	fdc42783          	lw	a5,-36(s0)
   113f8:	00f76c63          	bltu	a4,a5,11410 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   113fc:	fd842703          	lw	a4,-40(s0)
   11400:	fdc42783          	lw	a5,-36(s0)
   11404:	40f707b3          	sub	a5,a4,a5
   11408:	fcf42a23          	sw	a5,-44(s0)
   1140c:	0180006f          	j	11424 <altera_avalon_jtag_uart_read+0x78>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   11410:	000017b7          	lui	a5,0x1
   11414:	80078713          	addi	a4,a5,-2048 # 800 <_sig_func+0x800>
   11418:	fdc42783          	lw	a5,-36(s0)
   1141c:	40f707b3          	sub	a5,a4,a5
   11420:	fcf42a23          	sw	a5,-44(s0)

      if (n == 0)
   11424:	fd442783          	lw	a5,-44(s0)
   11428:	06078e63          	beqz	a5,114a4 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */

      if (n > space)
   1142c:	fc442783          	lw	a5,-60(s0)
   11430:	fd442703          	lw	a4,-44(s0)
   11434:	00e7f663          	bgeu	a5,a4,11440 <altera_avalon_jtag_uart_read+0x94>
        n = space;
   11438:	fc442783          	lw	a5,-60(s0)
   1143c:	fcf42a23          	sw	a5,-44(s0)

      memcpy(ptr, sp->rx_buf + out, n);
   11440:	fcc42783          	lw	a5,-52(s0)
   11444:	03878713          	addi	a4,a5,56
   11448:	fdc42783          	lw	a5,-36(s0)
   1144c:	00f707b3          	add	a5,a4,a5
   11450:	fd442603          	lw	a2,-44(s0)
   11454:	00078593          	mv	a1,a5
   11458:	fd042503          	lw	a0,-48(s0)
   1145c:	259010ef          	jal	ra,12eb4 <memcpy>
      ptr   += n;
   11460:	fd042703          	lw	a4,-48(s0)
   11464:	fd442783          	lw	a5,-44(s0)
   11468:	00f707b3          	add	a5,a4,a5
   1146c:	fcf42823          	sw	a5,-48(s0)
      space -= n;
   11470:	fc442703          	lw	a4,-60(s0)
   11474:	fd442783          	lw	a5,-44(s0)
   11478:	40f707b3          	sub	a5,a4,a5
   1147c:	fcf42223          	sw	a5,-60(s0)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   11480:	fdc42703          	lw	a4,-36(s0)
   11484:	fd442783          	lw	a5,-44(s0)
   11488:	00f707b3          	add	a5,a4,a5
   1148c:	7ff7f713          	andi	a4,a5,2047
   11490:	fcc42783          	lw	a5,-52(s0)
   11494:	02e7a623          	sw	a4,44(a5)
    }
    while (space > 0);
   11498:	fc442783          	lw	a5,-60(s0)
   1149c:	f2f04ee3          	bgtz	a5,113d8 <altera_avalon_jtag_uart_read+0x2c>
   114a0:	0080006f          	j	114a8 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */
   114a4:	00000013          	nop

    /* If we read any data then return it */
    if (ptr != buffer)
   114a8:	fd042703          	lw	a4,-48(s0)
   114ac:	fc842783          	lw	a5,-56(s0)
   114b0:	04f71c63          	bne	a4,a5,11508 <altera_avalon_jtag_uart_read+0x15c>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   114b4:	fc042703          	lw	a4,-64(s0)
   114b8:	000047b7          	lui	a5,0x4
   114bc:	00f777b3          	and	a5,a4,a5
   114c0:	04079863          	bnez	a5,11510 <altera_avalon_jtag_uart_read+0x164>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   114c4:	00000013          	nop
   114c8:	fcc42783          	lw	a5,-52(s0)
   114cc:	0287a783          	lw	a5,40(a5) # 4028 <_sig_func+0x4028>
   114d0:	fd842703          	lw	a4,-40(s0)
   114d4:	00f71c63          	bne	a4,a5,114ec <altera_avalon_jtag_uart_read+0x140>
   114d8:	fcc42783          	lw	a5,-52(s0)
   114dc:	0247a703          	lw	a4,36(a5)
   114e0:	fcc42783          	lw	a5,-52(s0)
   114e4:	0047a783          	lw	a5,4(a5)
   114e8:	fef760e3          	bltu	a4,a5,114c8 <altera_avalon_jtag_uart_read+0x11c>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   114ec:	fcc42783          	lw	a5,-52(s0)
   114f0:	0287a783          	lw	a5,40(a5)
   114f4:	fd842703          	lw	a4,-40(s0)
   114f8:	02f70063          	beq	a4,a5,11518 <altera_avalon_jtag_uart_read+0x16c>
  while (space > 0)
   114fc:	fc442783          	lw	a5,-60(s0)
   11500:	ecf04ce3          	bgtz	a5,113d8 <altera_avalon_jtag_uart_read+0x2c>
   11504:	0180006f          	j	1151c <altera_avalon_jtag_uart_read+0x170>
      break;
   11508:	00000013          	nop
   1150c:	0100006f          	j	1151c <altera_avalon_jtag_uart_read+0x170>
      break;
   11510:	00000013          	nop
   11514:	0080006f          	j	1151c <altera_avalon_jtag_uart_read+0x170>
      break;
   11518:	00000013          	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   1151c:	fd042703          	lw	a4,-48(s0)
   11520:	fc842783          	lw	a5,-56(s0)
   11524:	06f70463          	beq	a4,a5,1158c <altera_avalon_jtag_uart_read+0x1e0>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   11528:	00800793          	li	a5,8
   1152c:	3007b7f3          	csrrc	a5,mstatus,a5
   11530:	fef42623          	sw	a5,-20(s0)
    return context;
   11534:	fec42783          	lw	a5,-20(s0)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   11538:	fef42023          	sw	a5,-32(s0)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   1153c:	fcc42783          	lw	a5,-52(s0)
   11540:	0207a783          	lw	a5,32(a5)
   11544:	0017e713          	ori	a4,a5,1
   11548:	fcc42783          	lw	a5,-52(s0)
   1154c:	02e7a023          	sw	a4,32(a5)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   11550:	fcc42783          	lw	a5,-52(s0)
   11554:	0207a783          	lw	a5,32(a5)
   11558:	fef42223          	sw	a5,-28(s0)
   1155c:	fcc42783          	lw	a5,-52(s0)
   11560:	0007a783          	lw	a5,0(a5)
   11564:	00478793          	addi	a5,a5,4
   11568:	00078713          	mv	a4,a5
   1156c:	fe442783          	lw	a5,-28(s0)
   11570:	00f72023          	sw	a5,0(a4)
   11574:	fe042783          	lw	a5,-32(s0)
   11578:	fef42423          	sw	a5,-24(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   1157c:	fe842783          	lw	a5,-24(s0)
   11580:	0087f793          	andi	a5,a5,8
   11584:	3007a073          	csrs	mstatus,a5
}
   11588:	00000013          	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   1158c:	fd042703          	lw	a4,-48(s0)
   11590:	fc842783          	lw	a5,-56(s0)
   11594:	00f70a63          	beq	a4,a5,115a8 <altera_avalon_jtag_uart_read+0x1fc>
    return ptr - buffer;
   11598:	fd042703          	lw	a4,-48(s0)
   1159c:	fc842783          	lw	a5,-56(s0)
   115a0:	40f707b3          	sub	a5,a4,a5
   115a4:	0200006f          	j	115c4 <altera_avalon_jtag_uart_read+0x218>
  else if (flags & O_NONBLOCK)
   115a8:	fc042703          	lw	a4,-64(s0)
   115ac:	000047b7          	lui	a5,0x4
   115b0:	00f777b3          	and	a5,a4,a5
   115b4:	00078663          	beqz	a5,115c0 <altera_avalon_jtag_uart_read+0x214>
    return -EWOULDBLOCK;
   115b8:	ff500793          	li	a5,-11
   115bc:	0080006f          	j	115c4 <altera_avalon_jtag_uart_read+0x218>
  else
    return -EIO;
   115c0:	ffb00793          	li	a5,-5
}
   115c4:	00078513          	mv	a0,a5
   115c8:	03c12083          	lw	ra,60(sp)
   115cc:	03812403          	lw	s0,56(sp)
   115d0:	04010113          	addi	sp,sp,64
   115d4:	00008067          	ret

000115d8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   115d8:	fc010113          	addi	sp,sp,-64
   115dc:	02112e23          	sw	ra,60(sp)
   115e0:	02812c23          	sw	s0,56(sp)
   115e4:	04010413          	addi	s0,sp,64
   115e8:	fca42623          	sw	a0,-52(s0)
   115ec:	fcb42423          	sw	a1,-56(s0)
   115f0:	fcc42223          	sw	a2,-60(s0)
   115f4:	fcd42023          	sw	a3,-64(s0)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   115f8:	fc042823          	sw	zero,-48(s0)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   115fc:	fc842783          	lw	a5,-56(s0)
   11600:	fcf42c23          	sw	a5,-40(s0)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   11604:	0ec0006f          	j	116f0 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   11608:	fcc42783          	lw	a5,-52(s0)
   1160c:	0307a783          	lw	a5,48(a5) # 4030 <_sig_func+0x4030>
   11610:	fcf42e23          	sw	a5,-36(s0)
      out = sp->tx_out;
   11614:	fcc42783          	lw	a5,-52(s0)
   11618:	0347a783          	lw	a5,52(a5)
   1161c:	fcf42823          	sw	a5,-48(s0)

      if (in < out)
   11620:	fdc42703          	lw	a4,-36(s0)
   11624:	fd042783          	lw	a5,-48(s0)
   11628:	00f77e63          	bgeu	a4,a5,11644 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   1162c:	fd042703          	lw	a4,-48(s0)
   11630:	fdc42783          	lw	a5,-36(s0)
   11634:	40f707b3          	sub	a5,a4,a5
   11638:	fff78793          	addi	a5,a5,-1
   1163c:	fcf42a23          	sw	a5,-44(s0)
   11640:	0340006f          	j	11674 <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
   11644:	fd042783          	lw	a5,-48(s0)
   11648:	00078e63          	beqz	a5,11664 <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   1164c:	000017b7          	lui	a5,0x1
   11650:	80078713          	addi	a4,a5,-2048 # 800 <_sig_func+0x800>
   11654:	fdc42783          	lw	a5,-36(s0)
   11658:	40f707b3          	sub	a5,a4,a5
   1165c:	fcf42a23          	sw	a5,-44(s0)
   11660:	0140006f          	j	11674 <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   11664:	7ff00713          	li	a4,2047
   11668:	fdc42783          	lw	a5,-36(s0)
   1166c:	40f707b3          	sub	a5,a4,a5
   11670:	fcf42a23          	sw	a5,-44(s0)

      if (n == 0)
   11674:	fd442783          	lw	a5,-44(s0)
   11678:	08078263          	beqz	a5,116fc <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
   1167c:	fc442783          	lw	a5,-60(s0)
   11680:	fd442703          	lw	a4,-44(s0)
   11684:	00e7f663          	bgeu	a5,a4,11690 <altera_avalon_jtag_uart_write+0xb8>
        n = count;
   11688:	fc442783          	lw	a5,-60(s0)
   1168c:	fcf42a23          	sw	a5,-44(s0)

      memcpy(sp->tx_buf + in, ptr, n);
   11690:	fcc42703          	lw	a4,-52(s0)
   11694:	000017b7          	lui	a5,0x1
   11698:	83878793          	addi	a5,a5,-1992 # 838 <_sig_func+0x838>
   1169c:	00f70733          	add	a4,a4,a5
   116a0:	fdc42783          	lw	a5,-36(s0)
   116a4:	00f707b3          	add	a5,a4,a5
   116a8:	fd442603          	lw	a2,-44(s0)
   116ac:	fc842583          	lw	a1,-56(s0)
   116b0:	00078513          	mv	a0,a5
   116b4:	001010ef          	jal	ra,12eb4 <memcpy>
      ptr   += n;
   116b8:	fc842703          	lw	a4,-56(s0)
   116bc:	fd442783          	lw	a5,-44(s0)
   116c0:	00f707b3          	add	a5,a4,a5
   116c4:	fcf42423          	sw	a5,-56(s0)
      count -= n;
   116c8:	fc442703          	lw	a4,-60(s0)
   116cc:	fd442783          	lw	a5,-44(s0)
   116d0:	40f707b3          	sub	a5,a4,a5
   116d4:	fcf42223          	sw	a5,-60(s0)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   116d8:	fdc42703          	lw	a4,-36(s0)
   116dc:	fd442783          	lw	a5,-44(s0)
   116e0:	00f707b3          	add	a5,a4,a5
   116e4:	7ff7f713          	andi	a4,a5,2047
   116e8:	fcc42783          	lw	a5,-52(s0)
   116ec:	02e7a823          	sw	a4,48(a5)
    while (count > 0)
   116f0:	fc442783          	lw	a5,-60(s0)
   116f4:	f0f04ae3          	bgtz	a5,11608 <altera_avalon_jtag_uart_write+0x30>
   116f8:	0080006f          	j	11700 <altera_avalon_jtag_uart_write+0x128>
        break;
   116fc:	00000013          	nop
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   11700:	00800793          	li	a5,8
   11704:	3007b7f3          	csrrc	a5,mstatus,a5
   11708:	fef42623          	sw	a5,-20(s0)
    return context;
   1170c:	fec42783          	lw	a5,-20(s0)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   11710:	fef42023          	sw	a5,-32(s0)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   11714:	fcc42783          	lw	a5,-52(s0)
   11718:	0207a783          	lw	a5,32(a5)
   1171c:	0027e713          	ori	a4,a5,2
   11720:	fcc42783          	lw	a5,-52(s0)
   11724:	02e7a023          	sw	a4,32(a5)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   11728:	fcc42783          	lw	a5,-52(s0)
   1172c:	0207a783          	lw	a5,32(a5)
   11730:	fef42223          	sw	a5,-28(s0)
   11734:	fcc42783          	lw	a5,-52(s0)
   11738:	0007a783          	lw	a5,0(a5)
   1173c:	00478793          	addi	a5,a5,4
   11740:	00078713          	mv	a4,a5
   11744:	fe442783          	lw	a5,-28(s0)
   11748:	00f72023          	sw	a5,0(a4)
   1174c:	fe042783          	lw	a5,-32(s0)
   11750:	fef42423          	sw	a5,-24(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   11754:	fe842783          	lw	a5,-24(s0)
   11758:	0087f793          	andi	a5,a5,8
   1175c:	3007a073          	csrs	mstatus,a5
}
   11760:	00000013          	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   11764:	fc442783          	lw	a5,-60(s0)
   11768:	04f05463          	blez	a5,117b0 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
   1176c:	fc042703          	lw	a4,-64(s0)
   11770:	000047b7          	lui	a5,0x4
   11774:	00f777b3          	and	a5,a4,a5
   11778:	04079263          	bnez	a5,117bc <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   1177c:	00000013          	nop
   11780:	fcc42783          	lw	a5,-52(s0)
   11784:	0347a783          	lw	a5,52(a5) # 4034 <_sig_func+0x4034>
   11788:	fd042703          	lw	a4,-48(s0)
   1178c:	00f71c63          	bne	a4,a5,117a4 <altera_avalon_jtag_uart_write+0x1cc>
   11790:	fcc42783          	lw	a5,-52(s0)
   11794:	0247a703          	lw	a4,36(a5)
   11798:	fcc42783          	lw	a5,-52(s0)
   1179c:	0047a783          	lw	a5,4(a5)
   117a0:	fef760e3          	bltu	a4,a5,11780 <altera_avalon_jtag_uart_write+0x1a8>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
   117a4:	fcc42783          	lw	a5,-52(s0)
   117a8:	0247a783          	lw	a5,36(a5)
   117ac:	00079c63          	bnez	a5,117c4 <altera_avalon_jtag_uart_write+0x1ec>
         break;
    }
  }
  while (count > 0);
   117b0:	fc442783          	lw	a5,-60(s0)
   117b4:	f2f04ee3          	bgtz	a5,116f0 <altera_avalon_jtag_uart_write+0x118>
   117b8:	0100006f          	j	117c8 <altera_avalon_jtag_uart_write+0x1f0>
        break;
   117bc:	00000013          	nop
   117c0:	0080006f          	j	117c8 <altera_avalon_jtag_uart_write+0x1f0>
         break;
   117c4:	00000013          	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   117c8:	fc842703          	lw	a4,-56(s0)
   117cc:	fd842783          	lw	a5,-40(s0)
   117d0:	00f70a63          	beq	a4,a5,117e4 <altera_avalon_jtag_uart_write+0x20c>
    return ptr - start;
   117d4:	fc842703          	lw	a4,-56(s0)
   117d8:	fd842783          	lw	a5,-40(s0)
   117dc:	40f707b3          	sub	a5,a4,a5
   117e0:	0200006f          	j	11800 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
   117e4:	fc042703          	lw	a4,-64(s0)
   117e8:	000047b7          	lui	a5,0x4
   117ec:	00f777b3          	and	a5,a4,a5
   117f0:	00078663          	beqz	a5,117fc <altera_avalon_jtag_uart_write+0x224>
    return -EWOULDBLOCK;
   117f4:	ff500793          	li	a5,-11
   117f8:	0080006f          	j	11800 <altera_avalon_jtag_uart_write+0x228>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   117fc:	ffb00793          	li	a5,-5
}
   11800:	00078513          	mv	a0,a5
   11804:	03c12083          	lw	ra,60(sp)
   11808:	03812403          	lw	s0,56(sp)
   1180c:	04010113          	addi	sp,sp,64
   11810:	00008067          	ret

00011814 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   11814:	fd010113          	addi	sp,sp,-48
   11818:	02112623          	sw	ra,44(sp)
   1181c:	02812423          	sw	s0,40(sp)
   11820:	03010413          	addi	s0,sp,48
   11824:	fca42e23          	sw	a0,-36(s0)
   11828:	fcb42c23          	sw	a1,-40(s0)
   1182c:	fcc42a23          	sw	a2,-44(s0)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   11830:	fdc42783          	lw	a5,-36(s0)
   11834:	0007a783          	lw	a5,0(a5) # 4000 <_sig_func+0x4000>
   11838:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_uart_read(&dev->state, buffer, space,
   1183c:	fec42783          	lw	a5,-20(s0)
   11840:	02878713          	addi	a4,a5,40
   11844:	fdc42783          	lw	a5,-36(s0)
   11848:	0087a783          	lw	a5,8(a5)
   1184c:	00078693          	mv	a3,a5
   11850:	fd442603          	lw	a2,-44(s0)
   11854:	fd842583          	lw	a1,-40(s0)
   11858:	00070513          	mv	a0,a4
   1185c:	4c8000ef          	jal	ra,11d24 <altera_avalon_uart_read>
   11860:	00050793          	mv	a5,a0
      fd->fd_flags);
}
   11864:	00078513          	mv	a0,a5
   11868:	02c12083          	lw	ra,44(sp)
   1186c:	02812403          	lw	s0,40(sp)
   11870:	03010113          	addi	sp,sp,48
   11874:	00008067          	ret

00011878 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   11878:	fd010113          	addi	sp,sp,-48
   1187c:	02112623          	sw	ra,44(sp)
   11880:	02812423          	sw	s0,40(sp)
   11884:	03010413          	addi	s0,sp,48
   11888:	fca42e23          	sw	a0,-36(s0)
   1188c:	fcb42c23          	sw	a1,-40(s0)
   11890:	fcc42a23          	sw	a2,-44(s0)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   11894:	fdc42783          	lw	a5,-36(s0)
   11898:	0007a783          	lw	a5,0(a5)
   1189c:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_uart_write(&dev->state, buffer, space,
   118a0:	fec42783          	lw	a5,-20(s0)
   118a4:	02878713          	addi	a4,a5,40
   118a8:	fdc42783          	lw	a5,-36(s0)
   118ac:	0087a783          	lw	a5,8(a5)
   118b0:	00078693          	mv	a3,a5
   118b4:	fd442603          	lw	a2,-44(s0)
   118b8:	fd842583          	lw	a1,-40(s0)
   118bc:	00070513          	mv	a0,a4
   118c0:	644000ef          	jal	ra,11f04 <altera_avalon_uart_write>
   118c4:	00050793          	mv	a5,a0
      fd->fd_flags);
}
   118c8:	00078513          	mv	a0,a5
   118cc:	02c12083          	lw	ra,44(sp)
   118d0:	02812403          	lw	s0,40(sp)
   118d4:	03010113          	addi	sp,sp,48
   118d8:	00008067          	ret

000118dc <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
   118dc:	fd010113          	addi	sp,sp,-48
   118e0:	02112623          	sw	ra,44(sp)
   118e4:	02812423          	sw	s0,40(sp)
   118e8:	03010413          	addi	s0,sp,48
   118ec:	fca42e23          	sw	a0,-36(s0)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   118f0:	fdc42783          	lw	a5,-36(s0)
   118f4:	0007a783          	lw	a5,0(a5)
   118f8:	fef42623          	sw	a5,-20(s0)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
   118fc:	fec42783          	lw	a5,-20(s0)
   11900:	02878713          	addi	a4,a5,40
   11904:	fdc42783          	lw	a5,-36(s0)
   11908:	0087a783          	lw	a5,8(a5)
   1190c:	00078593          	mv	a1,a5
   11910:	00070513          	mv	a0,a4
   11914:	3b8000ef          	jal	ra,11ccc <altera_avalon_uart_close>
   11918:	00050793          	mv	a5,a0
}
   1191c:	00078513          	mv	a0,a5
   11920:	02c12083          	lw	ra,44(sp)
   11924:	02812403          	lw	s0,40(sp)
   11928:	03010113          	addi	sp,sp,48
   1192c:	00008067          	ret

00011930 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
   11930:	fd010113          	addi	sp,sp,-48
   11934:	02112623          	sw	ra,44(sp)
   11938:	02812423          	sw	s0,40(sp)
   1193c:	03010413          	addi	s0,sp,48
   11940:	fca42e23          	sw	a0,-36(s0)
   11944:	fcb42c23          	sw	a1,-40(s0)
   11948:	fcc42a23          	sw	a2,-44(s0)
  void* base = sp->base;
   1194c:	fdc42783          	lw	a5,-36(s0)
   11950:	0007a783          	lw	a5,0(a5)
   11954:	fef42223          	sw	a5,-28(s0)
   11958:	00000793          	li	a5,0
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   1195c:	00079a63          	bnez	a5,11970 <altera_avalon_uart_init+0x40>
   11960:	00000793          	li	a5,0
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   11964:	00079663          	bnez	a5,11970 <altera_avalon_uart_init+0x40>
   11968:	00000793          	li	a5,0
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   1196c:	00078663          	beqz	a5,11978 <altera_avalon_uart_init+0x48>
   11970:	00100793          	li	a5,1
   11974:	0080006f          	j	1197c <altera_avalon_uart_init+0x4c>
   11978:	00000793          	li	a5,0
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   1197c:	fef42423          	sw	a5,-24(s0)
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
   11980:	fe842783          	lw	a5,-24(s0)
   11984:	04079663          	bnez	a5,119d0 <altera_avalon_uart_init+0xa0>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
   11988:	fdc42783          	lw	a5,-36(s0)
   1198c:	00001737          	lui	a4,0x1
   11990:	c8070713          	addi	a4,a4,-896 # c80 <_sig_func+0xc80>
   11994:	00e7a223          	sw	a4,4(a5)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
   11998:	fdc42783          	lw	a5,-36(s0)
   1199c:	0047a783          	lw	a5,4(a5)
   119a0:	fef42623          	sw	a5,-20(s0)
   119a4:	fe442783          	lw	a5,-28(s0)
   119a8:	00c78793          	addi	a5,a5,12
   119ac:	fec42703          	lw	a4,-20(s0)
   119b0:	00e7a023          	sw	a4,0(a5)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
   119b4:	00000713          	li	a4,0
   119b8:	fdc42683          	lw	a3,-36(s0)
   119bc:	000127b7          	lui	a5,0x12
   119c0:	9e478613          	addi	a2,a5,-1564 # 119e4 <altera_avalon_uart_irq>
   119c4:	fd442583          	lw	a1,-44(s0)
   119c8:	fd842503          	lw	a0,-40(s0)
   119cc:	60d000ef          	jal	ra,127d8 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
   119d0:	00000013          	nop
   119d4:	02c12083          	lw	ra,44(sp)
   119d8:	02812403          	lw	s0,40(sp)
   119dc:	03010113          	addi	sp,sp,48
   119e0:	00008067          	ret

000119e4 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
   119e4:	fc010113          	addi	sp,sp,-64
   119e8:	02112e23          	sw	ra,60(sp)
   119ec:	02812c23          	sw	s0,56(sp)
   119f0:	04010413          	addi	s0,sp,64
   119f4:	fca42623          	sw	a0,-52(s0)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
   119f8:	fcc42783          	lw	a5,-52(s0)
   119fc:	fcf42c23          	sw	a5,-40(s0)
  void* base               = sp->base;
   11a00:	fd842783          	lw	a5,-40(s0)
   11a04:	0007a783          	lw	a5,0(a5)
   11a08:	fcf42e23          	sw	a5,-36(s0)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
   11a0c:	fdc42783          	lw	a5,-36(s0)
   11a10:	00878793          	addi	a5,a5,8
   11a14:	0007a783          	lw	a5,0(a5)
   11a18:	fef42023          	sw	a5,-32(s0)
   11a1c:	fe042783          	lw	a5,-32(s0)
   11a20:	fef42223          	sw	a5,-28(s0)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
   11a24:	fe042423          	sw	zero,-24(s0)
   11a28:	fdc42783          	lw	a5,-36(s0)
   11a2c:	00878793          	addi	a5,a5,8
   11a30:	fe842703          	lw	a4,-24(s0)
   11a34:	00e7a023          	sw	a4,0(a5)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
   11a38:	fdc42783          	lw	a5,-36(s0)
   11a3c:	00878793          	addi	a5,a5,8
   11a40:	0007a783          	lw	a5,0(a5)
   11a44:	fef42623          	sw	a5,-20(s0)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
   11a48:	fe442783          	lw	a5,-28(s0)
   11a4c:	0807f793          	andi	a5,a5,128
   11a50:	00078863          	beqz	a5,11a60 <altera_avalon_uart_irq+0x7c>
  {
    altera_avalon_uart_rxirq(sp, status);
   11a54:	fe442583          	lw	a1,-28(s0)
   11a58:	fd842503          	lw	a0,-40(s0)
   11a5c:	030000ef          	jal	ra,11a8c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
   11a60:	fe442783          	lw	a5,-28(s0)
   11a64:	4407f793          	andi	a5,a5,1088
   11a68:	00078863          	beqz	a5,11a78 <altera_avalon_uart_irq+0x94>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
   11a6c:	fe442583          	lw	a1,-28(s0)
   11a70:	fd842503          	lw	a0,-40(s0)
   11a74:	100000ef          	jal	ra,11b74 <altera_avalon_uart_txirq>
  }
  

}
   11a78:	00000013          	nop
   11a7c:	03c12083          	lw	ra,60(sp)
   11a80:	03812403          	lw	s0,56(sp)
   11a84:	04010113          	addi	sp,sp,64
   11a88:	00008067          	ret

00011a8c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   11a8c:	fd010113          	addi	sp,sp,-48
   11a90:	02812623          	sw	s0,44(sp)
   11a94:	03010413          	addi	s0,sp,48
   11a98:	fca42e23          	sw	a0,-36(s0)
   11a9c:	fcb42c23          	sw	a1,-40(s0)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
   11aa0:	fd842783          	lw	a5,-40(s0)
   11aa4:	0037f793          	andi	a5,a5,3
   11aa8:	0a079e63          	bnez	a5,11b64 <altera_avalon_uart_rxirq+0xd8>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
   11aac:	fdc42783          	lw	a5,-36(s0)
   11ab0:	00c7a783          	lw	a5,12(a5)
   11ab4:	fdc42783          	lw	a5,-36(s0)
   11ab8:	0087a783          	lw	a5,8(a5)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, ALT_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   11abc:	fdc42783          	lw	a5,-36(s0)
   11ac0:	00c7a783          	lw	a5,12(a5)
   11ac4:	00178793          	addi	a5,a5,1
   11ac8:	03f7f793          	andi	a5,a5,63
   11acc:	fef42223          	sw	a5,-28(s0)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
   11ad0:	fdc42783          	lw	a5,-36(s0)
   11ad4:	0007a783          	lw	a5,0(a5)
   11ad8:	0007a783          	lw	a5,0(a5)
   11adc:	fef42423          	sw	a5,-24(s0)
   11ae0:	fe842703          	lw	a4,-24(s0)
   11ae4:	fdc42783          	lw	a5,-36(s0)
   11ae8:	00c7a783          	lw	a5,12(a5)
   11aec:	0ff77713          	zext.b	a4,a4
   11af0:	fdc42683          	lw	a3,-36(s0)
   11af4:	00f687b3          	add	a5,a3,a5
   11af8:	00e78e23          	sb	a4,28(a5)

  sp->rx_end = next;
   11afc:	fdc42783          	lw	a5,-36(s0)
   11b00:	fe442703          	lw	a4,-28(s0)
   11b04:	00e7a623          	sw	a4,12(a5)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   11b08:	fdc42783          	lw	a5,-36(s0)
   11b0c:	00c7a783          	lw	a5,12(a5)
   11b10:	00178793          	addi	a5,a5,1
   11b14:	03f7f793          	andi	a5,a5,63
   11b18:	fef42223          	sw	a5,-28(s0)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
   11b1c:	fdc42783          	lw	a5,-36(s0)
   11b20:	0087a783          	lw	a5,8(a5)
   11b24:	fe442703          	lw	a4,-28(s0)
   11b28:	04f71063          	bne	a4,a5,11b68 <altera_avalon_uart_rxirq+0xdc>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   11b2c:	fdc42783          	lw	a5,-36(s0)
   11b30:	0047a783          	lw	a5,4(a5)
   11b34:	f7f7f713          	andi	a4,a5,-129
   11b38:	fdc42783          	lw	a5,-36(s0)
   11b3c:	00e7a223          	sw	a4,4(a5)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
   11b40:	fdc42783          	lw	a5,-36(s0)
   11b44:	0047a783          	lw	a5,4(a5)
   11b48:	fef42623          	sw	a5,-20(s0)
   11b4c:	fdc42783          	lw	a5,-36(s0)
   11b50:	0007a783          	lw	a5,0(a5)
   11b54:	00c78793          	addi	a5,a5,12
   11b58:	fec42703          	lw	a4,-20(s0)
   11b5c:	00e7a023          	sw	a4,0(a5)
   11b60:	0080006f          	j	11b68 <altera_avalon_uart_rxirq+0xdc>
    return;
   11b64:	00000013          	nop
  }   
}
   11b68:	02c12403          	lw	s0,44(sp)
   11b6c:	03010113          	addi	sp,sp,48
   11b70:	00008067          	ret

00011b74 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   11b74:	fd010113          	addi	sp,sp,-48
   11b78:	02812623          	sw	s0,44(sp)
   11b7c:	03010413          	addi	s0,sp,48
   11b80:	fca42e23          	sw	a0,-36(s0)
   11b84:	fcb42c23          	sw	a1,-40(s0)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
   11b88:	fdc42783          	lw	a5,-36(s0)
   11b8c:	0107a703          	lw	a4,16(a5)
   11b90:	fdc42783          	lw	a5,-36(s0)
   11b94:	0147a783          	lw	a5,20(a5)
   11b98:	0cf70e63          	beq	a4,a5,11c74 <altera_avalon_uart_txirq+0x100>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   11b9c:	fdc42783          	lw	a5,-36(s0)
   11ba0:	0187a783          	lw	a5,24(a5)
   11ba4:	0027f793          	andi	a5,a5,2
   11ba8:	00078c63          	beqz	a5,11bc0 <altera_avalon_uart_txirq+0x4c>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   11bac:	fd842703          	lw	a4,-40(s0)
   11bb0:	000017b7          	lui	a5,0x1
   11bb4:	80078793          	addi	a5,a5,-2048 # 800 <_sig_func+0x800>
   11bb8:	00f777b3          	and	a5,a4,a5
    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   11bbc:	06078a63          	beqz	a5,11c30 <altera_avalon_uart_txirq+0xbc>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
   11bc0:	fdc42783          	lw	a5,-36(s0)
   11bc4:	0107a783          	lw	a5,16(a5)
   11bc8:	fdc42783          	lw	a5,-36(s0)
   11bcc:	0147a783          	lw	a5,20(a5)
                       ALT_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
   11bd0:	fdc42783          	lw	a5,-36(s0)
   11bd4:	0107a783          	lw	a5,16(a5)
   11bd8:	fdc42703          	lw	a4,-36(s0)
   11bdc:	00f707b3          	add	a5,a4,a5
   11be0:	05c7c783          	lbu	a5,92(a5)
   11be4:	0ff7f793          	zext.b	a5,a5
   11be8:	fef42423          	sw	a5,-24(s0)
   11bec:	fdc42783          	lw	a5,-36(s0)
   11bf0:	0007a783          	lw	a5,0(a5)
   11bf4:	00478793          	addi	a5,a5,4
   11bf8:	fe842703          	lw	a4,-24(s0)
   11bfc:	00e7a023          	sw	a4,0(a5)

      sp->tx_start = ((sp->tx_start) + 1) & ALT_AVALON_UART_BUF_MSK;
   11c00:	fdc42783          	lw	a5,-36(s0)
   11c04:	0107a783          	lw	a5,16(a5)
   11c08:	00178793          	addi	a5,a5,1
   11c0c:	03f7f713          	andi	a4,a5,63
   11c10:	fdc42783          	lw	a5,-36(s0)
   11c14:	00e7a823          	sw	a4,16(a5)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   11c18:	fdc42783          	lw	a5,-36(s0)
   11c1c:	0047a783          	lw	a5,4(a5)
   11c20:	0407e713          	ori	a4,a5,64
   11c24:	fdc42783          	lw	a5,-36(s0)
   11c28:	00e7a223          	sw	a4,4(a5)
   11c2c:	0480006f          	j	11c74 <altera_avalon_uart_txirq+0x100>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
   11c30:	fdc42783          	lw	a5,-36(s0)
   11c34:	0007a783          	lw	a5,0(a5)
   11c38:	00878793          	addi	a5,a5,8
   11c3c:	0007a783          	lw	a5,0(a5)
   11c40:	fef42223          	sw	a5,-28(s0)
   11c44:	fe442783          	lw	a5,-28(s0)
   11c48:	fcf42c23          	sw	a5,-40(s0)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   11c4c:	fd842703          	lw	a4,-40(s0)
   11c50:	000017b7          	lui	a5,0x1
   11c54:	80078793          	addi	a5,a5,-2048 # 800 <_sig_func+0x800>
   11c58:	00f777b3          	and	a5,a4,a5
   11c5c:	00079c63          	bnez	a5,11c74 <altera_avalon_uart_txirq+0x100>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   11c60:	fdc42783          	lw	a5,-36(s0)
   11c64:	0047a783          	lw	a5,4(a5)
   11c68:	fbf7f713          	andi	a4,a5,-65
   11c6c:	fdc42783          	lw	a5,-36(s0)
   11c70:	00e7a223          	sw	a4,4(a5)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
   11c74:	fdc42783          	lw	a5,-36(s0)
   11c78:	0107a703          	lw	a4,16(a5)
   11c7c:	fdc42783          	lw	a5,-36(s0)
   11c80:	0147a783          	lw	a5,20(a5)
   11c84:	00f71c63          	bne	a4,a5,11c9c <altera_avalon_uart_txirq+0x128>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   11c88:	fdc42783          	lw	a5,-36(s0)
   11c8c:	0047a783          	lw	a5,4(a5)
   11c90:	bbf7f713          	andi	a4,a5,-1089
   11c94:	fdc42783          	lw	a5,-36(s0)
   11c98:	00e7a223          	sw	a4,4(a5)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   11c9c:	fdc42783          	lw	a5,-36(s0)
   11ca0:	0047a783          	lw	a5,4(a5)
   11ca4:	fef42623          	sw	a5,-20(s0)
   11ca8:	fdc42783          	lw	a5,-36(s0)
   11cac:	0007a783          	lw	a5,0(a5)
   11cb0:	00c78793          	addi	a5,a5,12
   11cb4:	fec42703          	lw	a4,-20(s0)
   11cb8:	00e7a023          	sw	a4,0(a5)
}
   11cbc:	00000013          	nop
   11cc0:	02c12403          	lw	s0,44(sp)
   11cc4:	03010113          	addi	sp,sp,48
   11cc8:	00008067          	ret

00011ccc <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
   11ccc:	fe010113          	addi	sp,sp,-32
   11cd0:	00812e23          	sw	s0,28(sp)
   11cd4:	02010413          	addi	s0,sp,32
   11cd8:	fea42623          	sw	a0,-20(s0)
   11cdc:	feb42423          	sw	a1,-24(s0)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   11ce0:	01c0006f          	j	11cfc <altera_avalon_uart_close+0x30>
    if (flags & O_NONBLOCK) {
   11ce4:	fe842703          	lw	a4,-24(s0)
   11ce8:	000047b7          	lui	a5,0x4
   11cec:	00f777b3          	and	a5,a4,a5
   11cf0:	00078663          	beqz	a5,11cfc <altera_avalon_uart_close+0x30>
      return -EWOULDBLOCK; 
   11cf4:	ff500793          	li	a5,-11
   11cf8:	01c0006f          	j	11d14 <altera_avalon_uart_close+0x48>
  while (sp->tx_start != sp->tx_end) {
   11cfc:	fec42783          	lw	a5,-20(s0)
   11d00:	0107a703          	lw	a4,16(a5) # 4010 <_sig_func+0x4010>
   11d04:	fec42783          	lw	a5,-20(s0)
   11d08:	0147a783          	lw	a5,20(a5)
   11d0c:	fcf71ce3          	bne	a4,a5,11ce4 <altera_avalon_uart_close+0x18>
    }
  }

  return 0;
   11d10:	00000793          	li	a5,0
}
   11d14:	00078513          	mv	a0,a5
   11d18:	01c12403          	lw	s0,28(sp)
   11d1c:	02010113          	addi	sp,sp,32
   11d20:	00008067          	ret

00011d24 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
   11d24:	fb010113          	addi	sp,sp,-80
   11d28:	04812623          	sw	s0,76(sp)
   11d2c:	05010413          	addi	s0,sp,80
   11d30:	faa42e23          	sw	a0,-68(s0)
   11d34:	fab42c23          	sw	a1,-72(s0)
   11d38:	fac42a23          	sw	a2,-76(s0)
   11d3c:	fad42823          	sw	a3,-80(s0)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
   11d40:	fc0405a3          	sb	zero,-53(s0)
  int             count = 0;
   11d44:	fc042623          	sw	zero,-52(s0)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
   11d48:	fb042703          	lw	a4,-80(s0)
   11d4c:	000047b7          	lui	a5,0x4
   11d50:	00f777b3          	and	a5,a4,a5
   11d54:	0017b793          	seqz	a5,a5
   11d58:	0ff7f793          	zext.b	a5,a5
   11d5c:	fcf42823          	sw	a5,-48(s0)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   11d60:	0500006f          	j	11db0 <altera_avalon_uart_read+0x8c>
    {
      count++;
   11d64:	fcc42783          	lw	a5,-52(s0)
   11d68:	00178793          	addi	a5,a5,1 # 4001 <_sig_func+0x4001>
   11d6c:	fcf42623          	sw	a5,-52(s0)
      *ptr++ = sp->rx_buf[sp->rx_start];
   11d70:	fbc42783          	lw	a5,-68(s0)
   11d74:	0087a703          	lw	a4,8(a5)
   11d78:	fb842783          	lw	a5,-72(s0)
   11d7c:	00178693          	addi	a3,a5,1
   11d80:	fad42c23          	sw	a3,-72(s0)
   11d84:	fbc42683          	lw	a3,-68(s0)
   11d88:	00e68733          	add	a4,a3,a4
   11d8c:	01c74703          	lbu	a4,28(a4)
   11d90:	0ff77713          	zext.b	a4,a4
   11d94:	00e78023          	sb	a4,0(a5)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
   11d98:	fbc42783          	lw	a5,-68(s0)
   11d9c:	0087a783          	lw	a5,8(a5)
   11da0:	00178793          	addi	a5,a5,1
   11da4:	03f7f713          	andi	a4,a5,63
   11da8:	fbc42783          	lw	a5,-68(s0)
   11dac:	00e7a423          	sw	a4,8(a5)
    while ((count < len) && (sp->rx_start != sp->rx_end))
   11db0:	fcc42703          	lw	a4,-52(s0)
   11db4:	fb442783          	lw	a5,-76(s0)
   11db8:	00f75c63          	bge	a4,a5,11dd0 <altera_avalon_uart_read+0xac>
   11dbc:	fbc42783          	lw	a5,-68(s0)
   11dc0:	0087a703          	lw	a4,8(a5)
   11dc4:	fbc42783          	lw	a5,-68(s0)
   11dc8:	00c7a783          	lw	a5,12(a5)
   11dcc:	f8f71ce3          	bne	a4,a5,11d64 <altera_avalon_uart_read+0x40>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
   11dd0:	fcc42783          	lw	a5,-52(s0)
   11dd4:	08079e63          	bnez	a5,11e70 <altera_avalon_uart_read+0x14c>
   11dd8:	fbc42783          	lw	a5,-68(s0)
   11ddc:	0087a703          	lw	a4,8(a5)
   11de0:	fbc42783          	lw	a5,-68(s0)
   11de4:	00c7a783          	lw	a5,12(a5)
   11de8:	08f71463          	bne	a4,a5,11e70 <altera_avalon_uart_read+0x14c>
    {
      if (!block)
   11dec:	fd042783          	lw	a5,-48(s0)
   11df0:	00079e63          	bnez	a5,11e0c <altera_avalon_uart_read+0xe8>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
   11df4:	000167b7          	lui	a5,0x16
   11df8:	00b00713          	li	a4,11
   11dfc:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
        read_would_block = 1;
   11e00:	00100793          	li	a5,1
   11e04:	fcf405a3          	sb	a5,-53(s0)
        break;
   11e08:	0780006f          	j	11e80 <altera_avalon_uart_read+0x15c>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   11e0c:	00800793          	li	a5,8
   11e10:	3007b7f3          	csrrc	a5,mstatus,a5
   11e14:	fef42223          	sw	a5,-28(s0)
    return context;
   11e18:	fe442783          	lw	a5,-28(s0)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
   11e1c:	fcf42a23          	sw	a5,-44(s0)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   11e20:	fbc42783          	lw	a5,-68(s0)
   11e24:	0047a783          	lw	a5,4(a5)
   11e28:	0807e713          	ori	a4,a5,128
   11e2c:	fbc42783          	lw	a5,-68(s0)
   11e30:	00e7a223          	sw	a4,4(a5)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   11e34:	fbc42783          	lw	a5,-68(s0)
   11e38:	0047a783          	lw	a5,4(a5)
   11e3c:	fcf42c23          	sw	a5,-40(s0)
   11e40:	fbc42783          	lw	a5,-68(s0)
   11e44:	0007a783          	lw	a5,0(a5)
   11e48:	00c78793          	addi	a5,a5,12
   11e4c:	fd842703          	lw	a4,-40(s0)
   11e50:	00e7a023          	sw	a4,0(a5)
   11e54:	fd442783          	lw	a5,-44(s0)
   11e58:	fef42023          	sw	a5,-32(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   11e5c:	fe042783          	lw	a5,-32(s0)
   11e60:	0087f793          	andi	a5,a5,8
   11e64:	3007a073          	csrs	mstatus,a5
}
   11e68:	00000013          	nop
   11e6c:	00000013          	nop
                      ALT_FLAG_WAIT_SET_ANY_WITH_CONSUME,
                      ALT_FLAG_WAIT_MAX_TIMEOUT);
      }
    }
  }
  while (!count && len);
   11e70:	fcc42783          	lw	a5,-52(s0)
   11e74:	00079663          	bnez	a5,11e80 <altera_avalon_uart_read+0x15c>
   11e78:	fb442783          	lw	a5,-76(s0)
   11e7c:	f2079ae3          	bnez	a5,11db0 <altera_avalon_uart_read+0x8c>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   11e80:	00800793          	li	a5,8
   11e84:	3007b7f3          	csrrc	a5,mstatus,a5
   11e88:	fef42623          	sw	a5,-20(s0)
    return context;
   11e8c:	fec42783          	lw	a5,-20(s0)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
   11e90:	fcf42a23          	sw	a5,-44(s0)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   11e94:	fbc42783          	lw	a5,-68(s0)
   11e98:	0047a783          	lw	a5,4(a5)
   11e9c:	0807e713          	ori	a4,a5,128
   11ea0:	fbc42783          	lw	a5,-68(s0)
   11ea4:	00e7a223          	sw	a4,4(a5)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   11ea8:	fbc42783          	lw	a5,-68(s0)
   11eac:	0047a783          	lw	a5,4(a5)
   11eb0:	fcf42e23          	sw	a5,-36(s0)
   11eb4:	fbc42783          	lw	a5,-68(s0)
   11eb8:	0007a783          	lw	a5,0(a5)
   11ebc:	00c78793          	addi	a5,a5,12
   11ec0:	fdc42703          	lw	a4,-36(s0)
   11ec4:	00e7a023          	sw	a4,0(a5)
   11ec8:	fd442783          	lw	a5,-44(s0)
   11ecc:	fef42423          	sw	a5,-24(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   11ed0:	fe842783          	lw	a5,-24(s0)
   11ed4:	0087f793          	andi	a5,a5,8
   11ed8:	3007a073          	csrs	mstatus,a5
}
   11edc:	00000013          	nop
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
   11ee0:	fcb44783          	lbu	a5,-53(s0)
   11ee4:	00078663          	beqz	a5,11ef0 <altera_avalon_uart_read+0x1cc>
    return -EWOULDBLOCK;
   11ee8:	ff500793          	li	a5,-11
   11eec:	0080006f          	j	11ef4 <altera_avalon_uart_read+0x1d0>
  }
  else {
    return count;
   11ef0:	fcc42783          	lw	a5,-52(s0)
  }
}
   11ef4:	00078513          	mv	a0,a5
   11ef8:	04c12403          	lw	s0,76(sp)
   11efc:	05010113          	addi	sp,sp,80
   11f00:	00008067          	ret

00011f04 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
   11f04:	fb010113          	addi	sp,sp,-80
   11f08:	04812623          	sw	s0,76(sp)
   11f0c:	05010413          	addi	s0,sp,80
   11f10:	faa42e23          	sw	a0,-68(s0)
   11f14:	fab42c23          	sw	a1,-72(s0)
   11f18:	fac42a23          	sw	a2,-76(s0)
   11f1c:	fad42823          	sw	a3,-80(s0)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
   11f20:	fb442783          	lw	a5,-76(s0)
   11f24:	fcf42423          	sw	a5,-56(s0)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
   11f28:	fb042703          	lw	a4,-80(s0)
   11f2c:	000047b7          	lui	a5,0x4
   11f30:	00f777b3          	and	a5,a4,a5
   11f34:	fcf42623          	sw	a5,-52(s0)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   11f38:	0f00006f          	j	12028 <altera_avalon_uart_write+0x124>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   11f3c:	fbc42783          	lw	a5,-68(s0)
   11f40:	0147a783          	lw	a5,20(a5) # 4014 <_sig_func+0x4014>
   11f44:	00178793          	addi	a5,a5,1
   11f48:	03f7f793          	andi	a5,a5,63
   11f4c:	fcf42823          	sw	a5,-48(s0)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
   11f50:	fbc42783          	lw	a5,-68(s0)
   11f54:	0107a783          	lw	a5,16(a5)
   11f58:	fd042703          	lw	a4,-48(s0)
   11f5c:	08f71863          	bne	a4,a5,11fec <altera_avalon_uart_write+0xe8>
    {
      if (no_block)
   11f60:	fcc42783          	lw	a5,-52(s0)
   11f64:	00078a63          	beqz	a5,11f78 <altera_avalon_uart_write+0x74>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
   11f68:	000167b7          	lui	a5,0x16
   11f6c:	00b00713          	li	a4,11
   11f70:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
        break;
   11f74:	0bc0006f          	j	12030 <altera_avalon_uart_write+0x12c>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   11f78:	00800793          	li	a5,8
   11f7c:	3007b7f3          	csrrc	a5,mstatus,a5
   11f80:	fef42223          	sw	a5,-28(s0)
    return context;
   11f84:	fe442783          	lw	a5,-28(s0)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
   11f88:	fcf42a23          	sw	a5,-44(s0)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   11f8c:	fbc42783          	lw	a5,-68(s0)
   11f90:	0047a783          	lw	a5,4(a5)
   11f94:	4407e713          	ori	a4,a5,1088
   11f98:	fbc42783          	lw	a5,-68(s0)
   11f9c:	00e7a223          	sw	a4,4(a5)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   11fa0:	fbc42783          	lw	a5,-68(s0)
   11fa4:	0047a783          	lw	a5,4(a5)
   11fa8:	fcf42c23          	sw	a5,-40(s0)
   11fac:	fbc42783          	lw	a5,-68(s0)
   11fb0:	0007a783          	lw	a5,0(a5)
   11fb4:	00c78793          	addi	a5,a5,12
   11fb8:	fd842703          	lw	a4,-40(s0)
   11fbc:	00e7a023          	sw	a4,0(a5)
   11fc0:	fd442783          	lw	a5,-44(s0)
   11fc4:	fef42023          	sw	a5,-32(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   11fc8:	fe042783          	lw	a5,-32(s0)
   11fcc:	0087f793          	andi	a5,a5,8
   11fd0:	3007a073          	csrs	mstatus,a5
}
   11fd4:	00000013          	nop
   11fd8:	00000013          	nop
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         ALT_FLAG_WAIT_SET_ANY_WITH_CONSUME,
                         ALT_FLAG_WAIT_MAX_TIMEOUT);
        }
        while ((next == sp->tx_start));
   11fdc:	fbc42783          	lw	a5,-68(s0)
   11fe0:	0107a783          	lw	a5,16(a5)
   11fe4:	fd042703          	lw	a4,-48(s0)
   11fe8:	fef708e3          	beq	a4,a5,11fd8 <altera_avalon_uart_write+0xd4>
      }
    }

    count--;
   11fec:	fc842783          	lw	a5,-56(s0)
   11ff0:	fff78793          	addi	a5,a5,-1
   11ff4:	fcf42423          	sw	a5,-56(s0)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
   11ff8:	fb842783          	lw	a5,-72(s0)
   11ffc:	00178713          	addi	a4,a5,1
   12000:	fae42c23          	sw	a4,-72(s0)
   12004:	fbc42703          	lw	a4,-68(s0)
   12008:	01472683          	lw	a3,20(a4)
   1200c:	0007c703          	lbu	a4,0(a5)
   12010:	fbc42783          	lw	a5,-68(s0)
   12014:	00d787b3          	add	a5,a5,a3
   12018:	04e78e23          	sb	a4,92(a5)
    sp->tx_end = next;
   1201c:	fbc42783          	lw	a5,-68(s0)
   12020:	fd042703          	lw	a4,-48(s0)
   12024:	00e7aa23          	sw	a4,20(a5)
  while (count)
   12028:	fc842783          	lw	a5,-56(s0)
   1202c:	f00798e3          	bnez	a5,11f3c <altera_avalon_uart_write+0x38>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   12030:	00800793          	li	a5,8
   12034:	3007b7f3          	csrrc	a5,mstatus,a5
   12038:	fef42623          	sw	a5,-20(s0)
    return context;
   1203c:	fec42783          	lw	a5,-20(s0)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
   12040:	fcf42a23          	sw	a5,-44(s0)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   12044:	fbc42783          	lw	a5,-68(s0)
   12048:	0047a783          	lw	a5,4(a5)
   1204c:	4407e713          	ori	a4,a5,1088
   12050:	fbc42783          	lw	a5,-68(s0)
   12054:	00e7a223          	sw	a4,4(a5)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   12058:	fbc42783          	lw	a5,-68(s0)
   1205c:	0047a783          	lw	a5,4(a5)
   12060:	fcf42e23          	sw	a5,-36(s0)
   12064:	fbc42783          	lw	a5,-68(s0)
   12068:	0007a783          	lw	a5,0(a5)
   1206c:	00c78793          	addi	a5,a5,12
   12070:	fdc42703          	lw	a4,-36(s0)
   12074:	00e7a023          	sw	a4,0(a5)
   12078:	fd442783          	lw	a5,-44(s0)
   1207c:	fef42423          	sw	a5,-24(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   12080:	fe842783          	lw	a5,-24(s0)
   12084:	0087f793          	andi	a5,a5,8
   12088:	3007a073          	csrs	mstatus,a5
}
   1208c:	00000013          	nop
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
   12090:	fb442703          	lw	a4,-76(s0)
   12094:	fc842783          	lw	a5,-56(s0)
   12098:	40f707b3          	sub	a5,a4,a5
}
   1209c:	00078513          	mv	a0,a5
   120a0:	04c12403          	lw	s0,76(sp)
   120a4:	05010113          	addi	sp,sp,80
   120a8:	00008067          	ret

000120ac <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   120ac:	fc010113          	addi	sp,sp,-64
   120b0:	02812e23          	sw	s0,60(sp)
   120b4:	04010413          	addi	s0,sp,64
   120b8:	fca42623          	sw	a0,-52(s0)
   120bc:	fcb42423          	sw	a1,-56(s0)
   120c0:	fcc42223          	sw	a2,-60(s0)
   120c4:	fcd42023          	sw	a3,-64(s0)
  alt_irq_context irq_context;
  alt_u64 current_nticks = 0;
   120c8:	00000713          	li	a4,0
   120cc:	00000793          	li	a5,0
   120d0:	fee42423          	sw	a4,-24(s0)
   120d4:	fef42623          	sw	a5,-20(s0)
   120d8:	000167b7          	lui	a5,0x16
   120dc:	b707a783          	lw	a5,-1168(a5) # 15b70 <_alt_tick_rate>
  
  if (alt_ticks_per_second ())
   120e0:	12078263          	beqz	a5,12204 <alt_alarm_start+0x158>
  {
    if (alarm)
   120e4:	fcc42783          	lw	a5,-52(s0)
   120e8:	10078a63          	beqz	a5,121fc <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
   120ec:	fcc42783          	lw	a5,-52(s0)
   120f0:	fc442703          	lw	a4,-60(s0)
   120f4:	00e7a823          	sw	a4,16(a5)
      alarm->context  = context;
   120f8:	fcc42783          	lw	a5,-52(s0)
   120fc:	fc042703          	lw	a4,-64(s0)
   12100:	00e7aa23          	sw	a4,20(a5)
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   12104:	00800793          	li	a5,8
   12108:	3007b7f3          	csrrc	a5,mstatus,a5
   1210c:	fef42223          	sw	a5,-28(s0)
    return context;
   12110:	fe442783          	lw	a5,-28(s0)
 
      irq_context = alt_irq_disable_all ();
   12114:	fcf42a23          	sw	a5,-44(s0)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u64 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   12118:	000167b7          	lui	a5,0x16
   1211c:	b787a703          	lw	a4,-1160(a5) # 15b78 <_alt_nticks>
   12120:	b7c7a783          	lw	a5,-1156(a5)
      
      current_nticks = alt_nticks();
   12124:	fee42423          	sw	a4,-24(s0)
   12128:	fef42623          	sw	a5,-20(s0)
      
      alarm->time = (alt_u64)nticks + current_nticks + 1; 
   1212c:	fc842783          	lw	a5,-56(s0)
   12130:	00078813          	mv	a6,a5
   12134:	00000893          	li	a7,0
   12138:	fe842603          	lw	a2,-24(s0)
   1213c:	fec42683          	lw	a3,-20(s0)
   12140:	00c80733          	add	a4,a6,a2
   12144:	00070593          	mv	a1,a4
   12148:	0105b5b3          	sltu	a1,a1,a6
   1214c:	00d887b3          	add	a5,a7,a3
   12150:	00f586b3          	add	a3,a1,a5
   12154:	00068793          	mv	a5,a3
   12158:	00070613          	mv	a2,a4
   1215c:	00078693          	mv	a3,a5
   12160:	00100513          	li	a0,1
   12164:	00000593          	li	a1,0
   12168:	00a60733          	add	a4,a2,a0
   1216c:	00070813          	mv	a6,a4
   12170:	00c83833          	sltu	a6,a6,a2
   12174:	00b687b3          	add	a5,a3,a1
   12178:	00f806b3          	add	a3,a6,a5
   1217c:	00068793          	mv	a5,a3
   12180:	fcc42683          	lw	a3,-52(s0)
   12184:	00e6a423          	sw	a4,8(a3)
   12188:	00f6a623          	sw	a5,12(a3)
          
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   1218c:	fcc42783          	lw	a5,-52(s0)
   12190:	00014737          	lui	a4,0x14
   12194:	7d070713          	addi	a4,a4,2000 # 147d0 <alt_alarm_list>
   12198:	fce42e23          	sw	a4,-36(s0)
   1219c:	fef42023          	sw	a5,-32(s0)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   121a0:	fe042783          	lw	a5,-32(s0)
   121a4:	fdc42703          	lw	a4,-36(s0)
   121a8:	00e7a223          	sw	a4,4(a5)
  entry->next     = list->next;
   121ac:	fdc42783          	lw	a5,-36(s0)
   121b0:	0007a703          	lw	a4,0(a5)
   121b4:	fe042783          	lw	a5,-32(s0)
   121b8:	00e7a023          	sw	a4,0(a5)

  list->next->previous = entry;
   121bc:	fdc42783          	lw	a5,-36(s0)
   121c0:	0007a783          	lw	a5,0(a5)
   121c4:	fe042703          	lw	a4,-32(s0)
   121c8:	00e7a223          	sw	a4,4(a5)
  list->next           = entry;
   121cc:	fdc42783          	lw	a5,-36(s0)
   121d0:	fe042703          	lw	a4,-32(s0)
   121d4:	00e7a023          	sw	a4,0(a5)
}
   121d8:	00000013          	nop
   121dc:	fd442783          	lw	a5,-44(s0)
   121e0:	fcf42c23          	sw	a5,-40(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   121e4:	fd842783          	lw	a5,-40(s0)
   121e8:	0087f793          	andi	a5,a5,8
   121ec:	3007a073          	csrs	mstatus,a5
}
   121f0:	00000013          	nop
      alt_irq_enable_all (irq_context);

      return 0;
   121f4:	00000793          	li	a5,0
   121f8:	0100006f          	j	12208 <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
   121fc:	fea00793          	li	a5,-22
   12200:	0080006f          	j	12208 <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
   12204:	f7a00793          	li	a5,-134
  }
}
   12208:	00078513          	mv	a0,a5
   1220c:	03c12403          	lw	s0,60(sp)
   12210:	04010113          	addi	sp,sp,64
   12214:	00008067          	ret

00012218 <alt_busy_sleep>:

// For a 50 Mhz clock, this is 1,202,590,842.
#define US_PER_OUTER_LOOP ((alt_u64)CLOCKS_PER_OUTER_LOOP / (alt_u64)CPU_FREQUENCY_MHZ)

unsigned int alt_busy_sleep (unsigned int us)
{
   12218:	fd010113          	addi	sp,sp,-48
   1221c:	02112623          	sw	ra,44(sp)
   12220:	02812423          	sw	s0,40(sp)
   12224:	03010413          	addi	s0,sp,48
   12228:	fca42e23          	sw	a0,-36(s0)
 * is connected, use that. If no timer agent is connected, fallback to a low accuracy busy
 * loop. If accurate timing is desired for busy sleep (used by usleep), please be sure to
 * provide a timestamp source, or connect the timer agent.
 */
#if HAL_TIMESTAMP_ENABLED
    alt_timestamp_start();
   1222c:	199000ef          	jal	ra,12bc4 <alt_timestamp_start>
    const alt_timestamp_type end_time = (CPU_FREQUENCY_MHZ * us);
   12230:	fdc42703          	lw	a4,-36(s0)
   12234:	00070793          	mv	a5,a4
   12238:	00179793          	slli	a5,a5,0x1
   1223c:	00e787b3          	add	a5,a5,a4
   12240:	00379793          	slli	a5,a5,0x3
   12244:	00e787b3          	add	a5,a5,a4
   12248:	00279793          	slli	a5,a5,0x2
   1224c:	fef42423          	sw	a5,-24(s0)
   12250:	fe042623          	sw	zero,-20(s0)
    while (alt_timestamp() < end_time) {
   12254:	00000013          	nop
   12258:	1ad000ef          	jal	ra,12c04 <alt_timestamp>
   1225c:	00050713          	mv	a4,a0
   12260:	00058793          	mv	a5,a1
   12264:	fec42683          	lw	a3,-20(s0)
   12268:	00078613          	mv	a2,a5
   1226c:	fed666e3          	bltu	a2,a3,12258 <alt_busy_sleep+0x40>
   12270:	fec42683          	lw	a3,-20(s0)
   12274:	00078613          	mv	a2,a5
   12278:	00c69863          	bne	a3,a2,12288 <alt_busy_sleep+0x70>
   1227c:	fe842683          	lw	a3,-24(s0)
   12280:	00070793          	mv	a5,a4
   12284:	fcd7eae3          	bltu	a5,a3,12258 <alt_busy_sleep+0x40>
        );
    }
#endif
#endif /* #ifndef ALT_SIM_OPTIMIZE */

  return 0;
   12288:	00000793          	li	a5,0
}
   1228c:	00078513          	mv	a0,a5
   12290:	02c12083          	lw	ra,44(sp)
   12294:	02812403          	lw	s0,40(sp)
   12298:	03010113          	addi	sp,sp,48
   1229c:	00008067          	ret

000122a0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   122a0:	fd010113          	addi	sp,sp,-48
   122a4:	02112623          	sw	ra,44(sp)
   122a8:	02812423          	sw	s0,40(sp)
   122ac:	03010413          	addi	s0,sp,48
   122b0:	fca42e23          	sw	a0,-36(s0)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   122b4:	fdc42783          	lw	a5,-36(s0)
   122b8:	0207c463          	bltz	a5,122e0 <close+0x40>
   122bc:	fdc42703          	lw	a4,-36(s0)
   122c0:	00070793          	mv	a5,a4
   122c4:	00179793          	slli	a5,a5,0x1
   122c8:	00e787b3          	add	a5,a5,a4
   122cc:	00279793          	slli	a5,a5,0x2
   122d0:	00014737          	lui	a4,0x14
   122d4:	63c70713          	addi	a4,a4,1596 # 1463c <alt_fd_list>
   122d8:	00e787b3          	add	a5,a5,a4
   122dc:	0080006f          	j	122e4 <close+0x44>
   122e0:	00000793          	li	a5,0
   122e4:	fef42423          	sw	a5,-24(s0)

  if (fd)
   122e8:	fe842783          	lw	a5,-24(s0)
   122ec:	06078463          	beqz	a5,12354 <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   122f0:	fe842783          	lw	a5,-24(s0)
   122f4:	0007a783          	lw	a5,0(a5)
   122f8:	0107a783          	lw	a5,16(a5)
   122fc:	02078063          	beqz	a5,1231c <close+0x7c>
   12300:	fe842783          	lw	a5,-24(s0)
   12304:	0007a783          	lw	a5,0(a5)
   12308:	0107a783          	lw	a5,16(a5)
   1230c:	fe842503          	lw	a0,-24(s0)
   12310:	000780e7          	jalr	a5
   12314:	00050793          	mv	a5,a0
   12318:	0080006f          	j	12320 <close+0x80>
   1231c:	00000793          	li	a5,0
   12320:	fef42623          	sw	a5,-20(s0)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   12324:	fdc42503          	lw	a0,-36(s0)
   12328:	f58fe0ef          	jal	ra,10a80 <alt_release_fd>
    if (rval < 0)
   1232c:	fec42783          	lw	a5,-20(s0)
   12330:	0007de63          	bgez	a5,1234c <close+0xac>
    {
      ALT_ERRNO = -rval;
   12334:	fec42783          	lw	a5,-20(s0)
   12338:	40f00733          	neg	a4,a5
   1233c:	000167b7          	lui	a5,0x16
   12340:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
      return -1;
   12344:	fff00793          	li	a5,-1
   12348:	01c0006f          	j	12364 <close+0xc4>
    }
    return 0;
   1234c:	00000793          	li	a5,0
   12350:	0140006f          	j	12364 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   12354:	000167b7          	lui	a5,0x16
   12358:	05100713          	li	a4,81
   1235c:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
    return -1;
   12360:	fff00793          	li	a5,-1
  }
}
   12364:	00078513          	mv	a0,a5
   12368:	02c12083          	lw	ra,44(sp)
   1236c:	02812403          	lw	s0,40(sp)
   12370:	03010113          	addi	sp,sp,48
   12374:	00008067          	ret

00012378 <alt_dcache_flush_all>:

/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */
void alt_dcache_flush_all (void)
{
   12378:	ff010113          	addi	sp,sp,-16
   1237c:	00812623          	sw	s0,12(sp)
   12380:	01010413          	addi	s0,sp,16
    for (i = (char*)0; i < (char*) ALT_CPU_DCACHE_SIZE; i+= ALT_CPU_DCACHE_LINE_SIZE)
    { 
      DCACHE_CLEAN_BY_INDEX_VAL(i); 
    }
#endif
}
   12384:	00000013          	nop
   12388:	00c12403          	lw	s0,12(sp)
   1238c:	01010113          	addi	sp,sp,16
   12390:	00008067          	ret

00012394 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   12394:	fe010113          	addi	sp,sp,-32
   12398:	00812e23          	sw	s0,28(sp)
   1239c:	02010413          	addi	s0,sp,32
   123a0:	fea42623          	sw	a0,-20(s0)
   123a4:	feb42423          	sw	a1,-24(s0)
   123a8:	fec42223          	sw	a2,-28(s0)
  return len;
   123ac:	fe442783          	lw	a5,-28(s0)
}
   123b0:	00078513          	mv	a0,a5
   123b4:	01c12403          	lw	s0,28(sp)
   123b8:	02010113          	addi	sp,sp,32
   123bc:	00008067          	ret

000123c0 <alt_dev_reg>:
    }
    /* all other elements are set to zero */
  };
  
int alt_dev_reg (alt_dev* dev)
{
   123c0:	fe010113          	addi	sp,sp,-32
   123c4:	00112e23          	sw	ra,28(sp)
   123c8:	00812c23          	sw	s0,24(sp)
   123cc:	02010413          	addi	s0,sp,32
   123d0:	fea42623          	sw	a0,-20(s0)
    return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   123d4:	000147b7          	lui	a5,0x14
   123d8:	7c478593          	addi	a1,a5,1988 # 147c4 <alt_dev_list>
   123dc:	fec42503          	lw	a0,-20(s0)
   123e0:	01c000ef          	jal	ra,123fc <alt_dev_llist_insert>
   123e4:	00050793          	mv	a5,a0
}
   123e8:	00078513          	mv	a0,a5
   123ec:	01c12083          	lw	ra,28(sp)
   123f0:	01812403          	lw	s0,24(sp)
   123f4:	02010113          	addi	sp,sp,32
   123f8:	00008067          	ret

000123fc <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   123fc:	fd010113          	addi	sp,sp,-48
   12400:	02812623          	sw	s0,44(sp)
   12404:	03010413          	addi	s0,sp,48
   12408:	fca42e23          	sw	a0,-36(s0)
   1240c:	fcb42c23          	sw	a1,-40(s0)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   12410:	fdc42783          	lw	a5,-36(s0)
   12414:	00078863          	beqz	a5,12424 <alt_dev_llist_insert+0x28>
   12418:	fdc42783          	lw	a5,-36(s0)
   1241c:	0087a783          	lw	a5,8(a5)
   12420:	00079c63          	bnez	a5,12438 <alt_dev_llist_insert+0x3c>
  {
    ALT_ERRNO = EINVAL;
   12424:	000167b7          	lui	a5,0x16
   12428:	01600713          	li	a4,22
   1242c:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
    return -EINVAL;
   12430:	fea00793          	li	a5,-22
   12434:	0540006f          	j	12488 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   12438:	fdc42783          	lw	a5,-36(s0)
   1243c:	fd842703          	lw	a4,-40(s0)
   12440:	fee42423          	sw	a4,-24(s0)
   12444:	fef42623          	sw	a5,-20(s0)
  entry->previous = list;
   12448:	fec42783          	lw	a5,-20(s0)
   1244c:	fe842703          	lw	a4,-24(s0)
   12450:	00e7a223          	sw	a4,4(a5)
  entry->next     = list->next;
   12454:	fe842783          	lw	a5,-24(s0)
   12458:	0007a703          	lw	a4,0(a5)
   1245c:	fec42783          	lw	a5,-20(s0)
   12460:	00e7a023          	sw	a4,0(a5)
  list->next->previous = entry;
   12464:	fe842783          	lw	a5,-24(s0)
   12468:	0007a783          	lw	a5,0(a5)
   1246c:	fec42703          	lw	a4,-20(s0)
   12470:	00e7a223          	sw	a4,4(a5)
  list->next           = entry;
   12474:	fe842783          	lw	a5,-24(s0)
   12478:	fec42703          	lw	a4,-20(s0)
   1247c:	00e7a023          	sw	a4,0(a5)
}
   12480:	00000013          	nop

  return 0;  
   12484:	00000793          	li	a5,0
}
   12488:	00078513          	mv	a0,a5
   1248c:	02c12403          	lw	s0,44(sp)
   12490:	03010113          	addi	sp,sp,48
   12494:	00008067          	ret

00012498 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   12498:	fd010113          	addi	sp,sp,-48
   1249c:	02812623          	sw	s0,44(sp)
   124a0:	03010413          	addi	s0,sp,48
   124a4:	fca42e23          	sw	a0,-36(s0)
   124a8:	fcb42c23          	sw	a1,-40(s0)
    alt_dev* next=NULL; 
   124ac:	fe042223          	sw	zero,-28(s0)
    alt_32   len=0;
   124b0:	fe042423          	sw	zero,-24(s0)
    alt_32   MAX_STRING_LENGTH=1000;
   124b4:	3e800793          	li	a5,1000
   124b8:	fef42623          	sw	a5,-20(s0)
    
    if (llist == NULL) { return NULL; }
   124bc:	fd842783          	lw	a5,-40(s0)
   124c0:	00079663          	bnez	a5,124cc <alt_find_dev+0x34>
   124c4:	00000793          	li	a5,0
   124c8:	0e00006f          	j	125a8 <alt_find_dev+0x110>
    next = (alt_dev*) llist->next;
   124cc:	fd842783          	lw	a5,-40(s0)
   124d0:	0007a783          	lw	a5,0(a5)
   124d4:	fef42223          	sw	a5,-28(s0)
    /*
     * Check each list entry in turn, until a match is found, or we reach the
     * end of the list (i.e. next winds up pointing back to the list head).
     */ 

    while (next != (alt_dev*) llist)
   124d8:	0c00006f          	j	12598 <alt_find_dev+0x100>
    {
        len=0;
   124dc:	fe042423          	sw	zero,-24(s0)
        while ((name[len] != 0) && (next->name[len]!=0) && (len < MAX_STRING_LENGTH))
   124e0:	0380006f          	j	12518 <alt_find_dev+0x80>
        {
            if (next->name[len] != name[len]) { break; }
   124e4:	fe442783          	lw	a5,-28(s0)
   124e8:	0087a703          	lw	a4,8(a5)
   124ec:	fe842783          	lw	a5,-24(s0)
   124f0:	00f707b3          	add	a5,a4,a5
   124f4:	0007c703          	lbu	a4,0(a5)
   124f8:	fe842783          	lw	a5,-24(s0)
   124fc:	fdc42683          	lw	a3,-36(s0)
   12500:	00f687b3          	add	a5,a3,a5
   12504:	0007c783          	lbu	a5,0(a5)
   12508:	04f71663          	bne	a4,a5,12554 <alt_find_dev+0xbc>
            len++;
   1250c:	fe842783          	lw	a5,-24(s0)
   12510:	00178793          	addi	a5,a5,1
   12514:	fef42423          	sw	a5,-24(s0)
        while ((name[len] != 0) && (next->name[len]!=0) && (len < MAX_STRING_LENGTH))
   12518:	fe842783          	lw	a5,-24(s0)
   1251c:	fdc42703          	lw	a4,-36(s0)
   12520:	00f707b3          	add	a5,a4,a5
   12524:	0007c783          	lbu	a5,0(a5)
   12528:	02078863          	beqz	a5,12558 <alt_find_dev+0xc0>
   1252c:	fe442783          	lw	a5,-28(s0)
   12530:	0087a703          	lw	a4,8(a5)
   12534:	fe842783          	lw	a5,-24(s0)
   12538:	00f707b3          	add	a5,a4,a5
   1253c:	0007c783          	lbu	a5,0(a5)
   12540:	00078c63          	beqz	a5,12558 <alt_find_dev+0xc0>
   12544:	fe842703          	lw	a4,-24(s0)
   12548:	fec42783          	lw	a5,-20(s0)
   1254c:	f8f74ce3          	blt	a4,a5,124e4 <alt_find_dev+0x4c>
   12550:	0080006f          	j	12558 <alt_find_dev+0xc0>
            if (next->name[len] != name[len]) { break; }
   12554:	00000013          	nop
        }
    
        /* match found */
        if ((name[len] == 0) && (next->name[len]==0)) {  return next; }
   12558:	fe842783          	lw	a5,-24(s0)
   1255c:	fdc42703          	lw	a4,-36(s0)
   12560:	00f707b3          	add	a5,a4,a5
   12564:	0007c783          	lbu	a5,0(a5)
   12568:	02079263          	bnez	a5,1258c <alt_find_dev+0xf4>
   1256c:	fe442783          	lw	a5,-28(s0)
   12570:	0087a703          	lw	a4,8(a5)
   12574:	fe842783          	lw	a5,-24(s0)
   12578:	00f707b3          	add	a5,a4,a5
   1257c:	0007c783          	lbu	a5,0(a5)
   12580:	00079663          	bnez	a5,1258c <alt_find_dev+0xf4>
   12584:	fe442783          	lw	a5,-28(s0)
   12588:	0200006f          	j	125a8 <alt_find_dev+0x110>

        next = (alt_dev*) next->llist.next;
   1258c:	fe442783          	lw	a5,-28(s0)
   12590:	0007a783          	lw	a5,0(a5)
   12594:	fef42223          	sw	a5,-28(s0)
    while (next != (alt_dev*) llist)
   12598:	fe442703          	lw	a4,-28(s0)
   1259c:	fd842783          	lw	a5,-40(s0)
   125a0:	f2f71ee3          	bne	a4,a5,124dc <alt_find_dev+0x44>
    }
  
    /* No match found */
  
    return NULL;
   125a4:	00000793          	li	a5,0
}
   125a8:	00078513          	mv	a0,a5
   125ac:	02c12403          	lw	s0,44(sp)
   125b0:	03010113          	addi	sp,sp,48
   125b4:	00008067          	ret

000125b8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   125b8:	fd010113          	addi	sp,sp,-48
   125bc:	02812623          	sw	s0,44(sp)
   125c0:	03010413          	addi	s0,sp,48
   125c4:	fca42e23          	sw	a0,-36(s0)
    alt_dev* next = (alt_dev*) alt_fs_list.next;   
   125c8:	000147b7          	lui	a5,0x14
   125cc:	7bc78793          	addi	a5,a5,1980 # 147bc <alt_fs_list>
   125d0:	0007a783          	lw	a5,0(a5)
   125d4:	fef42223          	sw	a5,-28(s0)
    alt_32   len=0;
   125d8:	fe042423          	sw	zero,-24(s0)
    alt_32   MAX_STRING_LENGTH=1000;
   125dc:	3e800793          	li	a5,1000
   125e0:	fef42623          	sw	a5,-20(s0)
 
    /*
    * Check each list entry in turn, until a match is found, or we reach the
    * end of the list (i.e. next winds up pointing back to the list head).
    */ 
    while (next != (alt_dev*) &alt_fs_list)
   125e4:	0ec0006f          	j	126d0 <alt_find_file+0x118>
    {
        len=0;
   125e8:	fe042423          	sw	zero,-24(s0)
        while (len < MAX_STRING_LENGTH)    
   125ec:	0bc0006f          	j	126a8 <alt_find_file+0xf0>
        {
            if (((next->name[len]== '/') && (next->name[len+1] == 0)) || (next->name[len] == 0))
   125f0:	fe442783          	lw	a5,-28(s0)
   125f4:	0087a703          	lw	a4,8(a5)
   125f8:	fe842783          	lw	a5,-24(s0)
   125fc:	00f707b3          	add	a5,a4,a5
   12600:	0007c703          	lbu	a4,0(a5)
   12604:	02f00793          	li	a5,47
   12608:	02f71063          	bne	a4,a5,12628 <alt_find_file+0x70>
   1260c:	fe442783          	lw	a5,-28(s0)
   12610:	0087a703          	lw	a4,8(a5)
   12614:	fe842783          	lw	a5,-24(s0)
   12618:	00178793          	addi	a5,a5,1
   1261c:	00f707b3          	add	a5,a4,a5
   12620:	0007c783          	lbu	a5,0(a5)
   12624:	00078e63          	beqz	a5,12640 <alt_find_file+0x88>
   12628:	fe442783          	lw	a5,-28(s0)
   1262c:	0087a703          	lw	a4,8(a5)
   12630:	fe842783          	lw	a5,-24(s0)
   12634:	00f707b3          	add	a5,a4,a5
   12638:	0007c783          	lbu	a5,0(a5)
   1263c:	02079c63          	bnez	a5,12674 <alt_find_file+0xbc>
            { 
                if ((name[len]== '/') || (name[len] == 0))
   12640:	fe842783          	lw	a5,-24(s0)
   12644:	fdc42703          	lw	a4,-36(s0)
   12648:	00f707b3          	add	a5,a4,a5
   1264c:	0007c703          	lbu	a4,0(a5)
   12650:	02f00793          	li	a5,47
   12654:	00f70c63          	beq	a4,a5,1266c <alt_find_file+0xb4>
   12658:	fe842783          	lw	a5,-24(s0)
   1265c:	fdc42703          	lw	a4,-36(s0)
   12660:	00f707b3          	add	a5,a4,a5
   12664:	0007c783          	lbu	a5,0(a5)
   12668:	04079863          	bnez	a5,126b8 <alt_find_file+0x100>
                {
                    return next;
   1266c:	fe442783          	lw	a5,-28(s0)
   12670:	0740006f          	j	126e4 <alt_find_file+0x12c>
                }
                break;
            }
            
            if (next->name[len]!=name[len]) { break; }
   12674:	fe442783          	lw	a5,-28(s0)
   12678:	0087a703          	lw	a4,8(a5)
   1267c:	fe842783          	lw	a5,-24(s0)
   12680:	00f707b3          	add	a5,a4,a5
   12684:	0007c703          	lbu	a4,0(a5)
   12688:	fe842783          	lw	a5,-24(s0)
   1268c:	fdc42683          	lw	a3,-36(s0)
   12690:	00f687b3          	add	a5,a3,a5
   12694:	0007c783          	lbu	a5,0(a5)
   12698:	02f71463          	bne	a4,a5,126c0 <alt_find_file+0x108>
            len++;
   1269c:	fe842783          	lw	a5,-24(s0)
   126a0:	00178793          	addi	a5,a5,1
   126a4:	fef42423          	sw	a5,-24(s0)
        while (len < MAX_STRING_LENGTH)    
   126a8:	fe842703          	lw	a4,-24(s0)
   126ac:	fec42783          	lw	a5,-20(s0)
   126b0:	f4f740e3          	blt	a4,a5,125f0 <alt_find_file+0x38>
   126b4:	0100006f          	j	126c4 <alt_find_file+0x10c>
                break;
   126b8:	00000013          	nop
   126bc:	0080006f          	j	126c4 <alt_find_file+0x10c>
            if (next->name[len]!=name[len]) { break; }
   126c0:	00000013          	nop
        }  
        
        next = (alt_dev*) next->llist.next;
   126c4:	fe442783          	lw	a5,-28(s0)
   126c8:	0007a783          	lw	a5,0(a5)
   126cc:	fef42223          	sw	a5,-28(s0)
    while (next != (alt_dev*) &alt_fs_list)
   126d0:	fe442703          	lw	a4,-28(s0)
   126d4:	000147b7          	lui	a5,0x14
   126d8:	7bc78793          	addi	a5,a5,1980 # 147bc <alt_fs_list>
   126dc:	f0f716e3          	bne	a4,a5,125e8 <alt_find_file+0x30>
    }
  
    /* No match found */
  
    return NULL;     
   126e0:	00000793          	li	a5,0
}
   126e4:	00078513          	mv	a0,a5
   126e8:	02c12403          	lw	s0,44(sp)
   126ec:	03010113          	addi	sp,sp,48
   126f0:	00008067          	ret

000126f4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   126f4:	fd010113          	addi	sp,sp,-48
   126f8:	02812623          	sw	s0,44(sp)
   126fc:	03010413          	addi	s0,sp,48
   12700:	fca42e23          	sw	a0,-36(s0)
  alt_32 i;
  int rc = -EMFILE;
   12704:	fe800793          	li	a5,-24
   12708:	fef42623          	sw	a5,-20(s0)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   1270c:	fe042423          	sw	zero,-24(s0)
   12710:	0880006f          	j	12798 <alt_get_fd+0xa4>
  {
    if (!alt_fd_list[i].dev)
   12714:	000147b7          	lui	a5,0x14
   12718:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   1271c:	fe842703          	lw	a4,-24(s0)
   12720:	00070793          	mv	a5,a4
   12724:	00179793          	slli	a5,a5,0x1
   12728:	00e787b3          	add	a5,a5,a4
   1272c:	00279793          	slli	a5,a5,0x2
   12730:	00f687b3          	add	a5,a3,a5
   12734:	0007a783          	lw	a5,0(a5)
   12738:	04079a63          	bnez	a5,1278c <alt_get_fd+0x98>
    {
      alt_fd_list[i].dev = dev;
   1273c:	000147b7          	lui	a5,0x14
   12740:	63c78693          	addi	a3,a5,1596 # 1463c <alt_fd_list>
   12744:	fe842703          	lw	a4,-24(s0)
   12748:	00070793          	mv	a5,a4
   1274c:	00179793          	slli	a5,a5,0x1
   12750:	00e787b3          	add	a5,a5,a4
   12754:	00279793          	slli	a5,a5,0x2
   12758:	00f687b3          	add	a5,a3,a5
   1275c:	fdc42703          	lw	a4,-36(s0)
   12760:	00e7a023          	sw	a4,0(a5)
      if (i > alt_max_fd)
   12764:	000147b7          	lui	a5,0x14
   12768:	7cc7a783          	lw	a5,1996(a5) # 147cc <alt_max_fd>
   1276c:	fe842703          	lw	a4,-24(s0)
   12770:	00e7d863          	bge	a5,a4,12780 <alt_get_fd+0x8c>
      {
        alt_max_fd = i;
   12774:	000147b7          	lui	a5,0x14
   12778:	fe842703          	lw	a4,-24(s0)
   1277c:	7ce7a623          	sw	a4,1996(a5) # 147cc <alt_max_fd>
      }
      rc = i;
   12780:	fe842783          	lw	a5,-24(s0)
   12784:	fef42623          	sw	a5,-20(s0)
      goto alt_get_fd_exit;
   12788:	0200006f          	j	127a8 <alt_get_fd+0xb4>
  for (i = 0; i < ALT_MAX_FD; i++)
   1278c:	fe842783          	lw	a5,-24(s0)
   12790:	00178793          	addi	a5,a5,1
   12794:	fef42423          	sw	a5,-24(s0)
   12798:	fe842703          	lw	a4,-24(s0)
   1279c:	01f00793          	li	a5,31
   127a0:	f6e7dae3          	bge	a5,a4,12714 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
   127a4:	00000013          	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   127a8:	fec42783          	lw	a5,-20(s0)
}
   127ac:	00078513          	mv	a0,a5
   127b0:	02c12403          	lw	s0,44(sp)
   127b4:	03010113          	addi	sp,sp,48
   127b8:	00008067          	ret

000127bc <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   127bc:	ff010113          	addi	sp,sp,-16
   127c0:	00812623          	sw	s0,12(sp)
   127c4:	01010413          	addi	s0,sp,16
#if ALT_CPU_ICACHE_SIZE > 0
    __asm__ volatile("fence.i" ::: "memory");
#endif
}
   127c8:	00000013          	nop
   127cc:	00c12403          	lw	s0,12(sp)
   127d0:	01010113          	addi	sp,sp,16
   127d4:	00008067          	ret

000127d8 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int 
alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   127d8:	fd010113          	addi	sp,sp,-48
   127dc:	02112623          	sw	ra,44(sp)
   127e0:	02812423          	sw	s0,40(sp)
   127e4:	03010413          	addi	s0,sp,48
   127e8:	fea42623          	sw	a0,-20(s0)
   127ec:	feb42423          	sw	a1,-24(s0)
   127f0:	fec42223          	sw	a2,-28(s0)
   127f4:	fed42023          	sw	a3,-32(s0)
   127f8:	fce42e23          	sw	a4,-36(s0)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   127fc:	fdc42703          	lw	a4,-36(s0)
   12800:	fe042683          	lw	a3,-32(s0)
   12804:	fe442603          	lw	a2,-28(s0)
   12808:	fe842583          	lw	a1,-24(s0)
   1280c:	fec42503          	lw	a0,-20(s0)
   12810:	01c000ef          	jal	ra,1282c <alt_iic_isr_register>
   12814:	00050793          	mv	a5,a0
}  
   12818:	00078513          	mv	a0,a5
   1281c:	02c12083          	lw	ra,44(sp)
   12820:	02812403          	lw	s0,40(sp)
   12824:	03010113          	addi	sp,sp,48
   12828:	00008067          	ret

0001282c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   1282c:	fa010113          	addi	sp,sp,-96
   12830:	04812e23          	sw	s0,92(sp)
   12834:	06010413          	addi	s0,sp,96
   12838:	faa42e23          	sw	a0,-68(s0)
   1283c:	fab42c23          	sw	a1,-72(s0)
   12840:	fac42a23          	sw	a2,-76(s0)
   12844:	fad42823          	sw	a3,-80(s0)
   12848:	fae42623          	sw	a4,-84(s0)
  int rc = -EINVAL;  
   1284c:	fea00793          	li	a5,-22
   12850:	fcf42223          	sw	a5,-60(s0)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
   12854:	fb842783          	lw	a5,-72(s0)
   12858:	fcf42423          	sw	a5,-56(s0)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   1285c:	fc842703          	lw	a4,-56(s0)
   12860:	00f00793          	li	a5,15
   12864:	12e7c863          	blt	a5,a4,12994 <alt_iic_isr_register+0x168>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   12868:	00800793          	li	a5,8
   1286c:	3007b7f3          	csrrc	a5,mstatus,a5
   12870:	fcf42823          	sw	a5,-48(s0)
    return context;
   12874:	fd042783          	lw	a5,-48(s0)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
   12878:	fcf42623          	sw	a5,-52(s0)

    alt_irq[id].handler = isr;
   1287c:	000167b7          	lui	a5,0x16
   12880:	b9078713          	addi	a4,a5,-1136 # 15b90 <alt_irq>
   12884:	fc842783          	lw	a5,-56(s0)
   12888:	00379793          	slli	a5,a5,0x3
   1288c:	00f707b3          	add	a5,a4,a5
   12890:	fb442703          	lw	a4,-76(s0)
   12894:	00e7a023          	sw	a4,0(a5)
    alt_irq[id].context = isr_context;
   12898:	000167b7          	lui	a5,0x16
   1289c:	b9078713          	addi	a4,a5,-1136 # 15b90 <alt_irq>
   128a0:	fc842783          	lw	a5,-56(s0)
   128a4:	00379793          	slli	a5,a5,0x3
   128a8:	00f707b3          	add	a5,a4,a5
   128ac:	fb042703          	lw	a4,-80(s0)
   128b0:	00e7a223          	sw	a4,4(a5)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   128b4:	fb442783          	lw	a5,-76(s0)
   128b8:	06078263          	beqz	a5,1291c <alt_iic_isr_register+0xf0>
   128bc:	fc842783          	lw	a5,-56(s0)
   128c0:	fbc42703          	lw	a4,-68(s0)
   128c4:	fce42a23          	sw	a4,-44(s0)
   128c8:	fcf42c23          	sw	a5,-40(s0)
    int rc = ALT_REMAP_IRQ_NUM(irq);
   128cc:	fd842703          	lw	a4,-40(s0)
   128d0:	00f00793          	li	a5,15
   128d4:	00e7e863          	bltu	a5,a4,128e4 <alt_iic_isr_register+0xb8>
   128d8:	fd842783          	lw	a5,-40(s0)
   128dc:	01078793          	addi	a5,a5,16
   128e0:	0080006f          	j	128e8 <alt_iic_isr_register+0xbc>
   128e4:	fff00793          	li	a5,-1
   128e8:	fcf42e23          	sw	a5,-36(s0)
    if (rc < 0)
   128ec:	fdc42783          	lw	a5,-36(s0)
   128f0:	0007d663          	bgez	a5,128fc <alt_iic_isr_register+0xd0>
        return rc;
   128f4:	fdc42783          	lw	a5,-36(s0)
   128f8:	0800006f          	j	12978 <alt_iic_isr_register+0x14c>
        irq = (alt_u32)rc;
   128fc:	fdc42783          	lw	a5,-36(s0)
   12900:	fcf42c23          	sw	a5,-40(s0)
    NIOSV_SET_CSR(NIOSV_MIE_CSR, 0x1 << irq);
   12904:	fd842783          	lw	a5,-40(s0)
   12908:	00100713          	li	a4,1
   1290c:	00f717b3          	sll	a5,a4,a5
   12910:	3047a073          	csrs	mie,a5
    return 0;
   12914:	00000793          	li	a5,0
   12918:	0600006f          	j	12978 <alt_iic_isr_register+0x14c>
   1291c:	fc842783          	lw	a5,-56(s0)
   12920:	fbc42703          	lw	a4,-68(s0)
   12924:	fee42023          	sw	a4,-32(s0)
   12928:	fef42223          	sw	a5,-28(s0)
    int rc = ALT_REMAP_IRQ_NUM(irq);
   1292c:	fe442703          	lw	a4,-28(s0)
   12930:	00f00793          	li	a5,15
   12934:	00e7e863          	bltu	a5,a4,12944 <alt_iic_isr_register+0x118>
   12938:	fe442783          	lw	a5,-28(s0)
   1293c:	01078793          	addi	a5,a5,16
   12940:	0080006f          	j	12948 <alt_iic_isr_register+0x11c>
   12944:	fff00793          	li	a5,-1
   12948:	fef42423          	sw	a5,-24(s0)
    if (rc < 0)
   1294c:	fe842783          	lw	a5,-24(s0)
   12950:	0007d663          	bgez	a5,1295c <alt_iic_isr_register+0x130>
        return rc;
   12954:	fe842783          	lw	a5,-24(s0)
   12958:	0200006f          	j	12978 <alt_iic_isr_register+0x14c>
        irq = (alt_u32)rc;
   1295c:	fe842783          	lw	a5,-24(s0)
   12960:	fef42223          	sw	a5,-28(s0)
    NIOSV_CLR_CSR(NIOSV_MIE_CSR, 0x1 << irq);
   12964:	fe442783          	lw	a5,-28(s0)
   12968:	00100713          	li	a4,1
   1296c:	00f717b3          	sll	a5,a4,a5
   12970:	3047b073          	csrc	mie,a5
    return 0;
   12974:	00000793          	li	a5,0
   12978:	fcf42223          	sw	a5,-60(s0)
   1297c:	fcc42783          	lw	a5,-52(s0)
   12980:	fef42623          	sw	a5,-20(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   12984:	fec42783          	lw	a5,-20(s0)
   12988:	0087f793          	andi	a5,a5,8
   1298c:	3007a073          	csrs	mstatus,a5
}
   12990:	00000013          	nop

    alt_irq_enable_all(status);
  }

  return rc; 
   12994:	fc442783          	lw	a5,-60(s0)
}
   12998:	00078513          	mv	a0,a5
   1299c:	05c12403          	lw	s0,92(sp)
   129a0:	06010113          	addi	sp,sp,96
   129a4:	00008067          	ret

000129a8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   129a8:	fd010113          	addi	sp,sp,-48
   129ac:	02812623          	sw	s0,44(sp)
   129b0:	03010413          	addi	s0,sp,48
   129b4:	fca42e23          	sw	a0,-36(s0)
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   129b8:	00800793          	li	a5,8
   129bc:	3007b7f3          	csrrc	a5,mstatus,a5
   129c0:	fef42623          	sw	a5,-20(s0)
    return context;
   129c4:	fec42783          	lw	a5,-20(s0)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   129c8:	fef42023          	sw	a5,-32(s0)
  alt_llist_remove (&alarm->llist);
   129cc:	fdc42783          	lw	a5,-36(s0)
   129d0:	fef42423          	sw	a5,-24(s0)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   129d4:	fe842783          	lw	a5,-24(s0)
   129d8:	0007a783          	lw	a5,0(a5)
   129dc:	fe842703          	lw	a4,-24(s0)
   129e0:	00472703          	lw	a4,4(a4)
   129e4:	00e7a223          	sw	a4,4(a5)
  entry->previous->next = entry->next;
   129e8:	fe842783          	lw	a5,-24(s0)
   129ec:	0047a783          	lw	a5,4(a5)
   129f0:	fe842703          	lw	a4,-24(s0)
   129f4:	00072703          	lw	a4,0(a4)
   129f8:	00e7a023          	sw	a4,0(a5)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   129fc:	fe842783          	lw	a5,-24(s0)
   12a00:	fe842703          	lw	a4,-24(s0)
   12a04:	00e7a223          	sw	a4,4(a5)
  entry->next     = entry;
   12a08:	fe842783          	lw	a5,-24(s0)
   12a0c:	fe842703          	lw	a4,-24(s0)
   12a10:	00e7a023          	sw	a4,0(a5)
} 
   12a14:	00000013          	nop
   12a18:	fe042783          	lw	a5,-32(s0)
   12a1c:	fef42223          	sw	a5,-28(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   12a20:	fe442783          	lw	a5,-28(s0)
   12a24:	0087f793          	andi	a5,a5,8
   12a28:	3007a073          	csrs	mstatus,a5
}
   12a2c:	00000013          	nop
  alt_irq_enable_all (irq_context);
}
   12a30:	00000013          	nop
   12a34:	02c12403          	lw	s0,44(sp)
   12a38:	03010113          	addi	sp,sp,48
   12a3c:	00008067          	ret

00012a40 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   12a40:	fe010113          	addi	sp,sp,-32
   12a44:	00112e23          	sw	ra,28(sp)
   12a48:	00812c23          	sw	s0,24(sp)
   12a4c:	01212a23          	sw	s2,20(sp)
   12a50:	01312823          	sw	s3,16(sp)
   12a54:	02010413          	addi	s0,sp,32
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   12a58:	000147b7          	lui	a5,0x14
   12a5c:	7d078793          	addi	a5,a5,2000 # 147d0 <alt_alarm_list>
   12a60:	0007a783          	lw	a5,0(a5)
   12a64:	fef42223          	sw	a5,-28(s0)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   12a68:	000167b7          	lui	a5,0x16
   12a6c:	b787a703          	lw	a4,-1160(a5) # 15b78 <_alt_nticks>
   12a70:	b7c7a783          	lw	a5,-1156(a5)
   12a74:	00100513          	li	a0,1
   12a78:	00000593          	li	a1,0
   12a7c:	00a70633          	add	a2,a4,a0
   12a80:	00060813          	mv	a6,a2
   12a84:	00e83833          	sltu	a6,a6,a4
   12a88:	00b786b3          	add	a3,a5,a1
   12a8c:	00d807b3          	add	a5,a6,a3
   12a90:	00078693          	mv	a3,a5
   12a94:	00060713          	mv	a4,a2
   12a98:	00068793          	mv	a5,a3
   12a9c:	000166b7          	lui	a3,0x16
   12aa0:	b6e6ac23          	sw	a4,-1160(a3) # 15b78 <_alt_nticks>
   12aa4:	b6f6ae23          	sw	a5,-1156(a3)
 
  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   12aa8:	0c80006f          	j	12b70 <alt_tick+0x130>
  {
    next = (alt_alarm*) alarm->llist.next;
   12aac:	fe442783          	lw	a5,-28(s0)
   12ab0:	0007a783          	lw	a5,0(a5)
   12ab4:	fef42423          	sw	a5,-24(s0)
    
    /* if the alarm period has expired, make the callback */    
    if (alarm->time <= _alt_nticks)
   12ab8:	fe442783          	lw	a5,-28(s0)
   12abc:	0087a603          	lw	a2,8(a5)
   12ac0:	00c7a683          	lw	a3,12(a5)
   12ac4:	000167b7          	lui	a5,0x16
   12ac8:	b787a703          	lw	a4,-1160(a5) # 15b78 <_alt_nticks>
   12acc:	b7c7a783          	lw	a5,-1156(a5)
   12ad0:	00068513          	mv	a0,a3
   12ad4:	00078593          	mv	a1,a5
   12ad8:	08a5e863          	bltu	a1,a0,12b68 <alt_tick+0x128>
   12adc:	00068513          	mv	a0,a3
   12ae0:	00078593          	mv	a1,a5
   12ae4:	00b51863          	bne	a0,a1,12af4 <alt_tick+0xb4>
   12ae8:	00060693          	mv	a3,a2
   12aec:	00070793          	mv	a5,a4
   12af0:	06d7ec63          	bltu	a5,a3,12b68 <alt_tick+0x128>
    {
      next_callback = alarm->callback (alarm->context);
   12af4:	fe442783          	lw	a5,-28(s0)
   12af8:	0107a783          	lw	a5,16(a5)
   12afc:	fe442703          	lw	a4,-28(s0)
   12b00:	01472703          	lw	a4,20(a4)
   12b04:	00070513          	mv	a0,a4
   12b08:	000780e7          	jalr	a5
   12b0c:	fea42623          	sw	a0,-20(s0)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   12b10:	fec42783          	lw	a5,-20(s0)
   12b14:	00079863          	bnez	a5,12b24 <alt_tick+0xe4>
      {
        alt_alarm_stop (alarm);
   12b18:	fe442503          	lw	a0,-28(s0)
   12b1c:	e8dff0ef          	jal	ra,129a8 <alt_alarm_stop>
   12b20:	0480006f          	j	12b68 <alt_tick+0x128>
      }
      else
      {
        alarm->time += next_callback;
   12b24:	fe442783          	lw	a5,-28(s0)
   12b28:	0087a703          	lw	a4,8(a5)
   12b2c:	00c7a783          	lw	a5,12(a5)
   12b30:	fec42683          	lw	a3,-20(s0)
   12b34:	00068913          	mv	s2,a3
   12b38:	00000993          	li	s3,0
   12b3c:	01270633          	add	a2,a4,s2
   12b40:	00060593          	mv	a1,a2
   12b44:	00e5b5b3          	sltu	a1,a1,a4
   12b48:	013786b3          	add	a3,a5,s3
   12b4c:	00d587b3          	add	a5,a1,a3
   12b50:	00078693          	mv	a3,a5
   12b54:	00060713          	mv	a4,a2
   12b58:	00068793          	mv	a5,a3
   12b5c:	fe442683          	lw	a3,-28(s0)
   12b60:	00e6a423          	sw	a4,8(a3)
   12b64:	00f6a623          	sw	a5,12(a3)
      }
    }
    alarm = next;
   12b68:	fe842783          	lw	a5,-24(s0)
   12b6c:	fef42223          	sw	a5,-28(s0)
  while (alarm != (alt_alarm*) &alt_alarm_list)
   12b70:	fe442703          	lw	a4,-28(s0)
   12b74:	000147b7          	lui	a5,0x14
   12b78:	7d078793          	addi	a5,a5,2000 # 147d0 <alt_alarm_list>
   12b7c:	f2f718e3          	bne	a4,a5,12aac <alt_tick+0x6c>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   12b80:	00000013          	nop
}
   12b84:	00000013          	nop
   12b88:	01c12083          	lw	ra,28(sp)
   12b8c:	01812403          	lw	s0,24(sp)
   12b90:	01412903          	lw	s2,20(sp)
   12b94:	01012983          	lw	s3,16(sp)
   12b98:	02010113          	addi	sp,sp,32
   12b9c:	00008067          	ret

00012ba0 <intel_niosv_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the mie
 * register so that all possible IRQs are disabled.
 */
void intel_niosv_irq_init(void) 
{
   12ba0:	ff010113          	addi	sp,sp,-16
   12ba4:	00812623          	sw	s0,12(sp)
   12ba8:	01010413          	addi	s0,sp,16
#if ALT_HAS_IRQ_SUPPORT
    NIOSV_CLR_CSR(NIOSV_MIE_CSR, NIOSV_MIE_MASK);
   12bac:	fff00793          	li	a5,-1
   12bb0:	3047b073          	csrc	mie,a5
#endif
}
   12bb4:	00000013          	nop
   12bb8:	00c12403          	lw	s0,12(sp)
   12bbc:	01010113          	addi	sp,sp,16
   12bc0:	00008067          	ret

00012bc4 <alt_timestamp_start>:
#define INTEL_NIOSV_TIMER_DEVICE_TYPE 2

#if (ALT_TIMESTAMP_CLK_TIMER_DEVICE_TYPE == INTEL_NIOSV_TIMER_DEVICE_TYPE)
alt_u64 alt_niosv_timestamp_offset = 0;

int alt_timestamp_start() {
   12bc4:	ff010113          	addi	sp,sp,-16
   12bc8:	00112623          	sw	ra,12(sp)
   12bcc:	00812423          	sw	s0,8(sp)
   12bd0:	01010413          	addi	s0,sp,16
void alt_niosv_timer_sc_isr(alt_u32 cause, alt_u32 epc, alt_u32 tval);

extern alt_u64 alt_niosv_timestamp_offset;

static ALT_INLINE int ALT_ALWAYS_INLINE alt_niosv_timer_timestamp_start() {
    alt_niosv_timestamp_offset = alt_niosv_mtime_get();
   12bd4:	0ac000ef          	jal	ra,12c80 <alt_niosv_mtime_get>
   12bd8:	00050713          	mv	a4,a0
   12bdc:	00058793          	mv	a5,a1
   12be0:	000166b7          	lui	a3,0x16
   12be4:	b8e6a023          	sw	a4,-1152(a3) # 15b80 <alt_niosv_timestamp_offset>
   12be8:	b8f6a223          	sw	a5,-1148(a3)
    return 0;
   12bec:	00000793          	li	a5,0
    return alt_niosv_timer_timestamp_start();
}
   12bf0:	00078513          	mv	a0,a5
   12bf4:	00c12083          	lw	ra,12(sp)
   12bf8:	00812403          	lw	s0,8(sp)
   12bfc:	01010113          	addi	sp,sp,16
   12c00:	00008067          	ret

00012c04 <alt_timestamp>:

alt_timestamp_type alt_timestamp() {
   12c04:	ff010113          	addi	sp,sp,-16
   12c08:	00112623          	sw	ra,12(sp)
   12c0c:	00812423          	sw	s0,8(sp)
   12c10:	01010413          	addi	s0,sp,16
}

static ALT_INLINE alt_u64 ALT_ALWAYS_INLINE alt_niosv_timer_timestamp() {
    return alt_niosv_mtime_get() - alt_niosv_timestamp_offset;
   12c14:	06c000ef          	jal	ra,12c80 <alt_niosv_mtime_get>
   12c18:	00050613          	mv	a2,a0
   12c1c:	00058693          	mv	a3,a1
   12c20:	000167b7          	lui	a5,0x16
   12c24:	b807a503          	lw	a0,-1152(a5) # 15b80 <alt_niosv_timestamp_offset>
   12c28:	b847a583          	lw	a1,-1148(a5)
   12c2c:	40a60733          	sub	a4,a2,a0
   12c30:	00070813          	mv	a6,a4
   12c34:	01063833          	sltu	a6,a2,a6
   12c38:	40b687b3          	sub	a5,a3,a1
   12c3c:	410786b3          	sub	a3,a5,a6
   12c40:	00068793          	mv	a5,a3
    return alt_niosv_timer_timestamp();
}
   12c44:	00070513          	mv	a0,a4
   12c48:	00078593          	mv	a1,a5
   12c4c:	00c12083          	lw	ra,12(sp)
   12c50:	00812403          	lw	s0,8(sp)
   12c54:	01010113          	addi	sp,sp,16
   12c58:	00008067          	ret

00012c5c <alt_timestamp_freq>:

alt_u32 alt_timestamp_freq() {
   12c5c:	ff010113          	addi	sp,sp,-16
   12c60:	00812623          	sw	s0,12(sp)
   12c64:	01010413          	addi	s0,sp,16
}

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_niosv_timer_timestamp_freq() {
    return ALT_CPU_CPU_FREQ;
   12c68:	05f5e7b7          	lui	a5,0x5f5e
   12c6c:	10078793          	addi	a5,a5,256 # 5f5e100 <__alt_data_end+0x5f42100>
    return alt_niosv_timer_timestamp_freq();
}
   12c70:	00078513          	mv	a0,a5
   12c74:	00c12403          	lw	s0,12(sp)
   12c78:	01010113          	addi	sp,sp,16
   12c7c:	00008067          	ret

00012c80 <alt_niosv_mtime_get>:
#endif

alt_u64 alt_niosv_mtime_get() {
   12c80:	fe010113          	addi	sp,sp,-32
   12c84:	00812e23          	sw	s0,28(sp)
   12c88:	02010413          	addi	s0,sp,32
    alt_u32 lowbits;
    alt_u32 highbits;

    // Guard against rollover while acquiring each word
    do {
        highbits = ALT_VOLATILE_ACCESS((alt_u32 *)(NIOSV_MTIME_ADDR + 4));
   12c8c:	00020337          	lui	t1,0x20
   12c90:	00c30313          	addi	t1,t1,12 # 2000c <__alt_data_end+0x400c>
   12c94:	00032303          	lw	t1,0(t1)
   12c98:	fe642423          	sw	t1,-24(s0)
        lowbits = ALT_VOLATILE_ACCESS((alt_u32 *)NIOSV_MTIME_ADDR);
   12c9c:	00020337          	lui	t1,0x20
   12ca0:	00830313          	addi	t1,t1,8 # 20008 <__alt_data_end+0x4008>
   12ca4:	00032303          	lw	t1,0(t1)
   12ca8:	fe642623          	sw	t1,-20(s0)
    } while (ALT_VOLATILE_ACCESS((alt_u32 *)(NIOSV_MTIME_ADDR + 4)) != highbits);
   12cac:	00020337          	lui	t1,0x20
   12cb0:	00c30313          	addi	t1,t1,12 # 2000c <__alt_data_end+0x400c>
   12cb4:	00032303          	lw	t1,0(t1)
   12cb8:	fe842e03          	lw	t3,-24(s0)
   12cbc:	fc6e18e3          	bne	t3,t1,12c8c <alt_niosv_mtime_get+0xc>

    return (((alt_u64)highbits) << 32) | lowbits;
   12cc0:	fe842303          	lw	t1,-24(s0)
   12cc4:	00030813          	mv	a6,t1
   12cc8:	00000893          	li	a7,0
   12ccc:	00081793          	slli	a5,a6,0x0
   12cd0:	00000713          	li	a4,0
   12cd4:	fec42803          	lw	a6,-20(s0)
   12cd8:	00080613          	mv	a2,a6
   12cdc:	00000693          	li	a3,0
   12ce0:	00c76533          	or	a0,a4,a2
   12ce4:	00d7e5b3          	or	a1,a5,a3
   12ce8:	00050713          	mv	a4,a0
   12cec:	00058793          	mv	a5,a1
}
   12cf0:	00070513          	mv	a0,a4
   12cf4:	00078593          	mv	a1,a5
   12cf8:	01c12403          	lw	s0,28(sp)
   12cfc:	02010113          	addi	sp,sp,32
   12d00:	00008067          	ret

00012d04 <alt_niosv_mtimecmp_set>:

void alt_niosv_mtimecmp_set(alt_u64 time) {
   12d04:	fe010113          	addi	sp,sp,-32
   12d08:	00812e23          	sw	s0,28(sp)
   12d0c:	02010413          	addi	s0,sp,32
   12d10:	fea42423          	sw	a0,-24(s0)
   12d14:	feb42623          	sw	a1,-20(s0)
    // Make sure to set the high word to a max value first to prevent triggering inadvertently
    ALT_VOLATILE_ACCESS((alt_u32 *)(NIOSV_MTIMECMP_ADDR + 4)) = 0xFFFFFFFF;
   12d18:	000206b7          	lui	a3,0x20
   12d1c:	00468693          	addi	a3,a3,4 # 20004 <__alt_data_end+0x4004>
   12d20:	fff00613          	li	a2,-1
   12d24:	00c6a023          	sw	a2,0(a3)
    ALT_VOLATILE_ACCESS((alt_u32 *)NIOSV_MTIMECMP_ADDR) = (alt_u32)time;
   12d28:	000206b7          	lui	a3,0x20
   12d2c:	fe842603          	lw	a2,-24(s0)
   12d30:	00c6a023          	sw	a2,0(a3) # 20000 <__alt_data_end+0x4000>
    ALT_VOLATILE_ACCESS((alt_u32 *)(NIOSV_MTIMECMP_ADDR + 4)) = (alt_u32)(time >> 32);
   12d34:	fec42683          	lw	a3,-20(s0)
   12d38:	0006d713          	srli	a4,a3,0x0
   12d3c:	00000793          	li	a5,0
   12d40:	000206b7          	lui	a3,0x20
   12d44:	00468693          	addi	a3,a3,4 # 20004 <__alt_data_end+0x4004>
   12d48:	00070793          	mv	a5,a4
   12d4c:	00f6a023          	sw	a5,0(a3)
}
   12d50:	00000013          	nop
   12d54:	01c12403          	lw	s0,28(sp)
   12d58:	02010113          	addi	sp,sp,32
   12d5c:	00008067          	ret

00012d60 <alt_niosv_mtimecmp_get>:

alt_u64 alt_niosv_mtimecmp_get() {
   12d60:	fe010113          	addi	sp,sp,-32
   12d64:	00812e23          	sw	s0,28(sp)
   12d68:	02010413          	addi	s0,sp,32
    alt_u32 lowbits = ALT_VOLATILE_ACCESS((alt_u32 *)NIOSV_MTIMECMP_ADDR);
   12d6c:	00020337          	lui	t1,0x20
   12d70:	00032303          	lw	t1,0(t1) # 20000 <__alt_data_end+0x4000>
   12d74:	fe642423          	sw	t1,-24(s0)
    alt_u32 highbits = ALT_VOLATILE_ACCESS((alt_u32 *)(NIOSV_MTIMECMP_ADDR + 4));
   12d78:	00020337          	lui	t1,0x20
   12d7c:	00430313          	addi	t1,t1,4 # 20004 <__alt_data_end+0x4004>
   12d80:	00032303          	lw	t1,0(t1)
   12d84:	fe642623          	sw	t1,-20(s0)
    return (((alt_u64)highbits) << 32) | lowbits;
   12d88:	fec42303          	lw	t1,-20(s0)
   12d8c:	00030813          	mv	a6,t1
   12d90:	00000893          	li	a7,0
   12d94:	00081793          	slli	a5,a6,0x0
   12d98:	00000713          	li	a4,0
   12d9c:	fe842803          	lw	a6,-24(s0)
   12da0:	00080613          	mv	a2,a6
   12da4:	00000693          	li	a3,0
   12da8:	00c76533          	or	a0,a4,a2
   12dac:	00d7e5b3          	or	a1,a5,a3
   12db0:	00050713          	mv	a4,a0
   12db4:	00058793          	mv	a5,a1
}
   12db8:	00070513          	mv	a0,a4
   12dbc:	00078593          	mv	a1,a5
   12dc0:	01c12403          	lw	s0,28(sp)
   12dc4:	02010113          	addi	sp,sp,32
   12dc8:	00008067          	ret

00012dcc <alt_niosv_timer_sc_isr>:
// Let's the OS port handles the machine timer configuration and interrupt if
// the OS port has it (ex: FreeRTOS).
void alt_niosv_timer_sc_isr(alt_u32 cause, alt_u32 epc, alt_u32 tval) {}
void alt_niosv_mtimecmp_interrupt_init() {}
#else
void alt_niosv_timer_sc_isr(alt_u32 cause, alt_u32 epc, alt_u32 tval) {
   12dcc:	fc010113          	addi	sp,sp,-64
   12dd0:	02112e23          	sw	ra,60(sp)
   12dd4:	02812c23          	sw	s0,56(sp)
   12dd8:	04010413          	addi	s0,sp,64
   12ddc:	fca42623          	sw	a0,-52(s0)
   12de0:	fcb42423          	sw	a1,-56(s0)
   12de4:	fcc42223          	sw	a2,-60(s0)
    // Schedule the next interrupt.  This is done first since who knows how long
    // the following code takes, and the contract is ticks per second, irrespective
    // of how long a given clock tick may take.

    alt_u64 curr_time = alt_niosv_mtime_get();
   12de8:	e99ff0ef          	jal	ra,12c80 <alt_niosv_mtime_get>
   12dec:	fea42423          	sw	a0,-24(s0)
   12df0:	feb42623          	sw	a1,-20(s0)
    alt_niosv_mtimecmp_set(curr_time + MTIMECMP_DELTA_AMT);
   12df4:	fe842703          	lw	a4,-24(s0)
   12df8:	fec42783          	lw	a5,-20(s0)
   12dfc:	00018537          	lui	a0,0x18
   12e00:	6a050513          	addi	a0,a0,1696 # 186a0 <__alt_heap_start+0x2a90>
   12e04:	00000593          	li	a1,0
   12e08:	00a70633          	add	a2,a4,a0
   12e0c:	00060813          	mv	a6,a2
   12e10:	00e83833          	sltu	a6,a6,a4
   12e14:	00b786b3          	add	a3,a5,a1
   12e18:	00d807b3          	add	a5,a6,a3
   12e1c:	00078693          	mv	a3,a5
   12e20:	00060713          	mv	a4,a2
   12e24:	00068793          	mv	a5,a3
   12e28:	00070513          	mv	a0,a4
   12e2c:	00078593          	mv	a1,a5
   12e30:	ed5ff0ef          	jal	ra,12d04 <alt_niosv_mtimecmp_set>
    NIOSV_READ_AND_CLR_CSR(NIOSV_MSTATUS_CSR, context, NIOSV_MSTATUS_MIE_MASK);
   12e34:	00800793          	li	a5,8
   12e38:	3007b7f3          	csrrc	a5,mstatus,a5
   12e3c:	fef42223          	sw	a5,-28(s0)
    return context;
   12e40:	fe442783          	lw	a5,-28(s0)

    /* 
    * Notify the system of a clock tick. disable interrupts 
    * during this time to safely support ISR preemption
    */
    alt_irq_context cpu_sr = alt_irq_disable_all();
   12e44:	fcf42e23          	sw	a5,-36(s0)
    alt_tick();
   12e48:	bf9ff0ef          	jal	ra,12a40 <alt_tick>
   12e4c:	fdc42783          	lw	a5,-36(s0)
   12e50:	fef42023          	sw	a5,-32(s0)
    NIOSV_SET_CSR(NIOSV_MSTATUS_CSR, context & NIOSV_MSTATUS_MIE_MASK);
   12e54:	fe042783          	lw	a5,-32(s0)
   12e58:	0087f793          	andi	a5,a5,8
   12e5c:	3007a073          	csrs	mstatus,a5
}
   12e60:	00000013          	nop
    alt_irq_enable_all(cpu_sr);
}
   12e64:	00000013          	nop
   12e68:	03c12083          	lw	ra,60(sp)
   12e6c:	03812403          	lw	s0,56(sp)
   12e70:	04010113          	addi	sp,sp,64
   12e74:	00008067          	ret

00012e78 <alt_niosv_mtimecmp_interrupt_init>:

void alt_niosv_mtimecmp_interrupt_init() {
   12e78:	ff010113          	addi	sp,sp,-16
   12e7c:	00112623          	sw	ra,12(sp)
   12e80:	00812423          	sw	s0,8(sp)
   12e84:	01010413          	addi	s0,sp,16
    alt_niosv_mtimecmp_set(MTIMECMP_MAX_VALUE);
   12e88:	fff00513          	li	a0,-1
   12e8c:	fff00593          	li	a1,-1
   12e90:	e75ff0ef          	jal	ra,12d04 <alt_niosv_mtimecmp_set>
    NIOSV_SET_CSR(NIOSV_MIE_CSR, (0x1 << NIOSV_TIMER_IRQ));
   12e94:	08000793          	li	a5,128
   12e98:	3047a073          	csrs	mie,a5
}
   12e9c:	00000013          	nop
    alt_niosv_enable_timer_interrupt();
}
   12ea0:	00000013          	nop
   12ea4:	00c12083          	lw	ra,12(sp)
   12ea8:	00812403          	lw	s0,8(sp)
   12eac:	01010113          	addi	sp,sp,16
   12eb0:	00008067          	ret

00012eb4 <memcpy>:
   12eb4:	00050313          	mv	t1,a0
   12eb8:	00060e63          	beqz	a2,12ed4 <memcpy+0x20>
   12ebc:	00058383          	lb	t2,0(a1)
   12ec0:	00730023          	sb	t2,0(t1)
   12ec4:	fff60613          	addi	a2,a2,-1
   12ec8:	00130313          	addi	t1,t1,1
   12ecc:	00158593          	addi	a1,a1,1
   12ed0:	fe0616e3          	bnez	a2,12ebc <memcpy+0x8>
   12ed4:	00008067          	ret

00012ed8 <__stack_chk_init>:
   12ed8:	00016537          	lui	a0,0x16
   12edc:	b8c52783          	lw	a5,-1140(a0) # 15b8c <__stack_chk_guard>
   12ee0:	02079463          	bnez	a5,12f08 <__stack_chk_init+0x30>
   12ee4:	00000793          	li	a5,0
   12ee8:	00078a63          	beqz	a5,12efc <__stack_chk_init+0x24>
   12eec:	00400593          	li	a1,4
   12ef0:	b8c50513          	addi	a0,a0,-1140
   12ef4:	00000317          	auipc	t1,0x0
   12ef8:	00000067          	jr	zero # 0 <_sig_func>
   12efc:	ff0a07b7          	lui	a5,0xff0a0
   12f00:	b8f52623          	sw	a5,-1140(a0)
   12f04:	00008067          	ret
   12f08:	00008067          	ret

00012f0c <__stack_chk_fail_weak>:
   12f0c:	1f4002ef          	jal	t0,13100 <__riscv_save_0>
   12f10:	00013537          	lui	a0,0x13
   12f14:	42050513          	addi	a0,a0,1056 # 13420 <__flash_rodata_start+0x74>
   12f18:	050000ef          	jal	ra,12f68 <puts>
   12f1c:	00600513          	li	a0,6
   12f20:	100000ef          	jal	ra,13020 <raise>
   12f24:	07f00513          	li	a0,127
   12f28:	238000ef          	jal	ra,13160 <_exit>

00012f2c <exit>:
   12f2c:	1d4002ef          	jal	t0,13100 <__riscv_save_0>
   12f30:	00000793          	li	a5,0
   12f34:	00050413          	mv	s0,a0
   12f38:	00078863          	beqz	a5,12f48 <exit+0x1c>
   12f3c:	00000593          	li	a1,0
   12f40:	00000097          	auipc	ra,0x0
   12f44:	000000e7          	jalr	zero # 0 <_sig_func>
   12f48:	088000ef          	jal	ra,12fd0 <__libc_fini_array>
   12f4c:	00040513          	mv	a0,s0
   12f50:	210000ef          	jal	ra,13160 <_exit>

00012f54 <fflush>:
   12f54:	01052783          	lw	a5,16(a0)
   12f58:	00078463          	beqz	a5,12f60 <fflush+0xc>
   12f5c:	00078067          	jr	a5 # ff0a0000 <__alt_data_end+0xff084000>
   12f60:	00000513          	li	a0,0
   12f64:	00008067          	ret

00012f68 <puts>:
   12f68:	198002ef          	jal	t0,13100 <__riscv_save_0>
   12f6c:	000137b7          	lui	a5,0x13
   12f70:	44c7a583          	lw	a1,1100(a5) # 1344c <stdout>
   12f74:	ff010113          	addi	sp,sp,-16
   12f78:	00050413          	mv	s0,a0
   12f7c:	0045c783          	lbu	a5,4(a1)
   12f80:	00000493          	li	s1,0
   12f84:	0027f793          	andi	a5,a5,2
   12f88:	02079463          	bnez	a5,12fb0 <puts+0x48>
   12f8c:	fff00493          	li	s1,-1
   12f90:	00048513          	mv	a0,s1
   12f94:	01010113          	addi	sp,sp,16
   12f98:	1b00006f          	j	13148 <__riscv_restore_0>
   12f9c:	00b12623          	sw	a1,12(sp)
   12fa0:	000780e7          	jalr	a5
   12fa4:	00c12583          	lw	a1,12(sp)
   12fa8:	00055463          	bgez	a0,12fb0 <puts+0x48>
   12fac:	fff00493          	li	s1,-1
   12fb0:	00044503          	lbu	a0,0(s0)
   12fb4:	00140413          	addi	s0,s0,1
   12fb8:	0085a783          	lw	a5,8(a1)
   12fbc:	fe0510e3          	bnez	a0,12f9c <puts+0x34>
   12fc0:	00a00513          	li	a0,10
   12fc4:	000780e7          	jalr	a5
   12fc8:	fc0554e3          	bgez	a0,12f90 <puts+0x28>
   12fcc:	fc1ff06f          	j	12f8c <puts+0x24>

00012fd0 <__libc_fini_array>:
   12fd0:	130002ef          	jal	t0,13100 <__riscv_save_0>
   12fd4:	000137b7          	lui	a5,0x13
   12fd8:	00013437          	lui	s0,0x13
   12fdc:	2b478713          	addi	a4,a5,692 # 132b4 <__fini_array_end>
   12fe0:	2b440413          	addi	s0,s0,692 # 132b4 <__fini_array_end>
   12fe4:	40e40433          	sub	s0,s0,a4
   12fe8:	40245413          	srai	s0,s0,0x2
   12fec:	2b478493          	addi	s1,a5,692
   12ff0:	00041c63          	bnez	s0,13008 <__libc_fini_array+0x38>
   12ff4:	00000793          	li	a5,0
   12ff8:	00078663          	beqz	a5,13004 <__libc_fini_array+0x34>
   12ffc:	00000097          	auipc	ra,0x0
   13000:	000000e7          	jalr	zero # 0 <_sig_func>
   13004:	1440006f          	j	13148 <__riscv_restore_0>
   13008:	fff40413          	addi	s0,s0,-1
   1300c:	00241793          	slli	a5,s0,0x2
   13010:	00f487b3          	add	a5,s1,a5
   13014:	0007a783          	lw	a5,0(a5)
   13018:	000780e7          	jalr	a5
   1301c:	fd5ff06f          	j	12ff0 <__libc_fini_array+0x20>

00013020 <raise>:
   13020:	01f00793          	li	a5,31
   13024:	00a7fc63          	bgeu	a5,a0,1303c <raise+0x1c>
   13028:	000167b7          	lui	a5,0x16
   1302c:	01600713          	li	a4,22
   13030:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
   13034:	fff00513          	li	a0,-1
   13038:	00008067          	ret
   1303c:	0c4002ef          	jal	t0,13100 <__riscv_save_0>
   13040:	00251713          	slli	a4,a0,0x2
   13044:	00020793          	mv	a5,tp
   13048:	00e787b3          	add	a5,a5,a4
   1304c:	0007a703          	lw	a4,0(a5)
   13050:	ff010113          	addi	sp,sp,-16
   13054:	00071e63          	bnez	a4,13070 <raise+0x50>
   13058:	00a12623          	sw	a0,12(sp)
   1305c:	144000ef          	jal	ra,131a0 <getpid>
   13060:	00c12583          	lw	a1,12(sp)
   13064:	15c000ef          	jal	ra,131c0 <kill>
   13068:	01010113          	addi	sp,sp,16
   1306c:	0dc0006f          	j	13148 <__riscv_restore_0>
   13070:	00100693          	li	a3,1
   13074:	02d70463          	beq	a4,a3,1309c <raise+0x7c>
   13078:	fff00693          	li	a3,-1
   1307c:	00d71c63          	bne	a4,a3,13094 <raise+0x74>
   13080:	000167b7          	lui	a5,0x16
   13084:	01600713          	li	a4,22
   13088:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
   1308c:	00100513          	li	a0,1
   13090:	fd9ff06f          	j	13068 <raise+0x48>
   13094:	0007a023          	sw	zero,0(a5)
   13098:	000700e7          	jalr	a4
   1309c:	00000513          	li	a0,0
   130a0:	fc9ff06f          	j	13068 <raise+0x48>

000130a4 <__riscv_save_12>:
   130a4:	fc010113          	addi	sp,sp,-64
   130a8:	00000313          	li	t1,0
   130ac:	01b12623          	sw	s11,12(sp)
   130b0:	00c0006f          	j	130bc <__riscv_save_10+0x8>

000130b4 <__riscv_save_10>:
   130b4:	fc010113          	addi	sp,sp,-64
   130b8:	ff000313          	li	t1,-16
   130bc:	01a12823          	sw	s10,16(sp)
   130c0:	01912a23          	sw	s9,20(sp)
   130c4:	01812c23          	sw	s8,24(sp)
   130c8:	01712e23          	sw	s7,28(sp)
   130cc:	00c0006f          	j	130d8 <__riscv_save_4+0x8>

000130d0 <__riscv_save_4>:
   130d0:	fc010113          	addi	sp,sp,-64
   130d4:	fe000313          	li	t1,-32
   130d8:	03612023          	sw	s6,32(sp)
   130dc:	03512223          	sw	s5,36(sp)
   130e0:	03412423          	sw	s4,40(sp)
   130e4:	03312623          	sw	s3,44(sp)
   130e8:	03212823          	sw	s2,48(sp)
   130ec:	02912a23          	sw	s1,52(sp)
   130f0:	02812c23          	sw	s0,56(sp)
   130f4:	02112e23          	sw	ra,60(sp)
   130f8:	40610133          	sub	sp,sp,t1
   130fc:	00028067          	jr	t0

00013100 <__riscv_save_0>:
   13100:	ff010113          	addi	sp,sp,-16
   13104:	01212023          	sw	s2,0(sp)
   13108:	00912223          	sw	s1,4(sp)
   1310c:	00812423          	sw	s0,8(sp)
   13110:	00112623          	sw	ra,12(sp)
   13114:	00028067          	jr	t0

00013118 <__riscv_restore_12>:
   13118:	00c12d83          	lw	s11,12(sp)
   1311c:	01010113          	addi	sp,sp,16

00013120 <__riscv_restore_10>:
   13120:	00012d03          	lw	s10,0(sp)
   13124:	00412c83          	lw	s9,4(sp)
   13128:	00812c03          	lw	s8,8(sp)
   1312c:	00c12b83          	lw	s7,12(sp)
   13130:	01010113          	addi	sp,sp,16

00013134 <__riscv_restore_4>:
   13134:	00012b03          	lw	s6,0(sp)
   13138:	00412a83          	lw	s5,4(sp)
   1313c:	00812a03          	lw	s4,8(sp)
   13140:	00c12983          	lw	s3,12(sp)
   13144:	01010113          	addi	sp,sp,16

00013148 <__riscv_restore_0>:
   13148:	00012903          	lw	s2,0(sp)
   1314c:	00412483          	lw	s1,4(sp)
   13150:	00812403          	lw	s0,8(sp)
   13154:	00c12083          	lw	ra,12(sp)
   13158:	01010113          	addi	sp,sp,16
   1315c:	00008067          	ret

00013160 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   13160:	fd010113          	addi	sp,sp,-48
   13164:	02812623          	sw	s0,44(sp)
   13168:	03010413          	addi	s0,sp,48
   1316c:	fca42e23          	sw	a0,-36(s0)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   13170:	00000013          	nop
   13174:	fdc42783          	lw	a5,-36(s0)
   13178:	fef42623          	sw	a5,-20(s0)
 * Routine called on exit.
 * TODO: Add support for GMON/gprof.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int a0 asm ("a0") = exit_code;
   1317c:	fec42503          	lw	a0,-20(s0)
    "ebreak" 
    : 
    : "r"(a0), "r"(a1));

#else /* !DEBUG_STUB */
  if (a0) {
   13180:	00050793          	mv	a5,a0
   13184:	00078663          	beqz	a5,13190 <_exit+0x30>
    ALT_SIM_FAIL();
   13188:	7c103013          	sltiu	zero,zero,1985
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
   1318c:	0080006f          	j	13194 <_exit+0x34>
    ALT_SIM_PASS();
   13190:	7c203013          	sltiu	zero,zero,1986
}
   13194:	00000013          	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   13198:	00000013          	nop
   1319c:	ffdff06f          	j	13198 <_exit+0x38>

000131a0 <getpid>:
 *
 * ALT_GETPID is mapped onto the getpid() system call in alt_syscall.h
 */
 
int ALT_GETPID (void)
{
   131a0:	ff010113          	addi	sp,sp,-16
   131a4:	00812623          	sw	s0,12(sp)
   131a8:	01010413          	addi	s0,sp,16
  return 0;
   131ac:	00000793          	li	a5,0
}
   131b0:	00078513          	mv	a0,a5
   131b4:	00c12403          	lw	s0,12(sp)
   131b8:	01010113          	addi	sp,sp,16
   131bc:	00008067          	ret

000131c0 <kill>:
 *
 * ALT_KILL is mapped onto the kill() system call in alt_syscall.h
 */

int ALT_KILL (int pid, int sig)
{
   131c0:	fd010113          	addi	sp,sp,-48
   131c4:	02112623          	sw	ra,44(sp)
   131c8:	02812423          	sw	s0,40(sp)
   131cc:	03010413          	addi	s0,sp,48
   131d0:	fca42e23          	sw	a0,-36(s0)
   131d4:	fcb42c23          	sw	a1,-40(s0)
  int status = 0;
   131d8:	fe042623          	sw	zero,-20(s0)

  if (pid <= 0)
   131dc:	fdc42783          	lw	a5,-36(s0)
   131e0:	06f04e63          	bgtz	a5,1325c <kill+0x9c>
  {
    switch (sig)
   131e4:	fd842783          	lw	a5,-40(s0)
   131e8:	08078463          	beqz	a5,13270 <kill+0xb0>
   131ec:	fd842783          	lw	a5,-40(s0)
   131f0:	0607c063          	bltz	a5,13250 <kill+0x90>
   131f4:	fd842703          	lw	a4,-40(s0)
   131f8:	01f00793          	li	a5,31
   131fc:	04e7ca63          	blt	a5,a4,13250 <kill+0x90>
   13200:	fd842703          	lw	a4,-40(s0)
   13204:	00300793          	li	a5,3
   13208:	04f74463          	blt	a4,a5,13250 <kill+0x90>
   1320c:	fd842783          	lw	a5,-40(s0)
   13210:	00100713          	li	a4,1
   13214:	00f717b3          	sll	a5,a4,a5
   13218:	cf810737          	lui	a4,0xcf810
   1321c:	f7870713          	addi	a4,a4,-136 # cf80ff78 <__alt_data_end+0xcf7f3f78>
   13220:	00e7f733          	and	a4,a5,a4
   13224:	00e03733          	snez	a4,a4
   13228:	0ff77713          	zext.b	a4,a4
   1322c:	00071e63          	bnez	a4,13248 <kill+0x88>
   13230:	00110737          	lui	a4,0x110
   13234:	00e7f7b3          	and	a5,a5,a4
   13238:	00f037b3          	snez	a5,a5
   1323c:	0ff7f793          	zext.b	a5,a5
   13240:	02079c63          	bnez	a5,13278 <kill+0xb8>
   13244:	00c0006f          	j	13250 <kill+0x90>
       * The Posix standard defines the default behaviour for all these signals 
       * as being eqivalent to a call to _exit(). No mechanism is provided to 
       * change this behaviour.
       */

      _exit(0);
   13248:	00000513          	li	a0,0
   1324c:	f15ff0ef          	jal	ra,13160 <_exit>
      break;
    default:

      /* Tried to send an unsupported signal */

      status = EINVAL;
   13250:	01600793          	li	a5,22
   13254:	fef42623          	sw	a5,-20(s0)
   13258:	0240006f          	j	1327c <kill+0xbc>
    }
  }

  else if (pid > 0)
   1325c:	fdc42783          	lw	a5,-36(s0)
   13260:	00f05e63          	blez	a5,1327c <kill+0xbc>
  {
    /* Attempted to signal a non-existant process */

    status = ESRCH;
   13264:	00300793          	li	a5,3
   13268:	fef42623          	sw	a5,-20(s0)
   1326c:	0100006f          	j	1327c <kill+0xbc>
      break;
   13270:	00000013          	nop
   13274:	0080006f          	j	1327c <kill+0xbc>
      break;
   13278:	00000013          	nop
  }

  if (status)
   1327c:	fec42783          	lw	a5,-20(s0)
   13280:	00078c63          	beqz	a5,13298 <kill+0xd8>
  {
    ALT_ERRNO = status;
   13284:	000167b7          	lui	a5,0x16
   13288:	fec42703          	lw	a4,-20(s0)
   1328c:	b8e7a423          	sw	a4,-1144(a5) # 15b88 <errno>
    return -1;
   13290:	fff00793          	li	a5,-1
   13294:	0080006f          	j	1329c <kill+0xdc>
  }

  return 0;
   13298:	00000793          	li	a5,0
}
   1329c:	00078513          	mv	a0,a5
   132a0:	02c12083          	lw	ra,44(sp)
   132a4:	02812403          	lw	s0,40(sp)
   132a8:	03010113          	addi	sp,sp,48
   132ac:	00008067          	ret
   132b0:	2ed8                	.2byte	0x2ed8
   132b2:	0001                	.2byte	0x1
   132b4:	0010                	.2byte	0x10
   132b6:	0000                	.2byte	0x0
   132b8:	0000                	.2byte	0x0
   132ba:	0000                	.2byte	0x0
   132bc:	00527a03          	.4byte	0x527a03
   132c0:	7c01                	.2byte	0x7c01
   132c2:	0105                	.2byte	0x105
   132c4:	00020d1b          	.4byte	0x20d1b
   132c8:	0048                	.2byte	0x48
   132ca:	0000                	.2byte	0x0
   132cc:	0018                	.2byte	0x18
   132ce:	0000                	.2byte	0x0
   132d0:	fdd4                	.2byte	0xfdd4
   132d2:	ffff                	.2byte	0xffff
   132d4:	005c                	.2byte	0x5c
   132d6:	0000                	.2byte	0x0
   132d8:	4400                	.2byte	0x4400
   132da:	400e                	.2byte	0x400e
   132dc:	9b48                	.2byte	0x9b48
   132de:	440d                	.2byte	0x440d
   132e0:	400e44db          	.4byte	0x400e44db
   132e4:	9a48                	.2byte	0x9a48
   132e6:	440c                	.2byte	0x440c
   132e8:	0b99                	.2byte	0xb99
   132ea:	9844                	.2byte	0x9844
   132ec:	440a                	.2byte	0x440a
   132ee:	d7440997          	auipc	s3,0xd7440
   132f2:	d9d8                	.2byte	0xd9d8
   132f4:	dbda                	.2byte	0xdbda
   132f6:	0e44                	.2byte	0xe44
   132f8:	4840                	.2byte	0x4840
   132fa:	0896                	.2byte	0x896
   132fc:	9544                	.2byte	0x9544
   132fe:	06944407          	.4byte	0x6944407
   13302:	9344                	.2byte	0x9344
   13304:	4405                	.2byte	0x4405
   13306:	0492                	.2byte	0x492
   13308:	8944                	.2byte	0x8944
   1330a:	02884403          	lbu	s0,40(a6)
   1330e:	8144                	.2byte	0x8144
   13310:	0001                	.2byte	0x1
   13312:	0000                	.2byte	0x0
   13314:	001c                	.2byte	0x1c
   13316:	0000                	.2byte	0x0
   13318:	0064                	.2byte	0x64
   1331a:	0000                	.2byte	0x0
   1331c:	fde4                	.2byte	0xfde4
   1331e:	ffff                	.2byte	0xffff
   13320:	0018                	.2byte	0x18
   13322:	0000                	.2byte	0x0
   13324:	4400                	.2byte	0x4400
   13326:	100e                	.2byte	0x100e
   13328:	8948                	.2byte	0x8948
   1332a:	4404                	.2byte	0x4404
   1332c:	0288                	.2byte	0x288
   1332e:	8144                	.2byte	0x8144
   13330:	0001                	.2byte	0x1
   13332:	0000                	.2byte	0x0
   13334:	002c                	.2byte	0x2c
   13336:	0000                	.2byte	0x0
   13338:	0000                	.2byte	0x0
   1333a:	0000                	.2byte	0x0
   1333c:	00527a03          	.4byte	0x527a03
   13340:	7c01                	.2byte	0x7c01
   13342:	0101                	.2byte	0x101
   13344:	0e020d1b          	.4byte	0xe020d1b
   13348:	9b40                	.2byte	0x9b40
   1334a:	9a0d                	.2byte	0x9a0d
   1334c:	990c                	.2byte	0x990c
   1334e:	970a980b          	.4byte	0x970a980b
   13352:	9609                	.2byte	0x9609
   13354:	9508                	.2byte	0x9508
   13356:	93069407          	.4byte	0x93069407
   1335a:	9205                	.2byte	0x9205
   1335c:	8904                	.2byte	0x8904
   1335e:	81028803          	lb	a6,-2032(t0)
   13362:	0001                	.2byte	0x1
   13364:	0044                	.2byte	0x44
   13366:	0000                	.2byte	0x0
   13368:	0034                	.2byte	0x34
   1336a:	0000                	.2byte	0x0
   1336c:	fdac                	.2byte	0xfdac
   1336e:	ffff                	.2byte	0xffff
   13370:	0048                	.2byte	0x48
   13372:	0000                	.2byte	0x0
   13374:	4400                	.2byte	0x4400
   13376:	0edb44db          	.4byte	0xedb44db
   1337a:	4430                	.2byte	0x4430
   1337c:	44da                	.2byte	0x44da
   1337e:	44d9                	.2byte	0x44d9
   13380:	44d8                	.2byte	0x44d8
   13382:	d8d744d7          	.4byte	0xd8d744d7
   13386:	dad9                	.2byte	0xdad9
   13388:	44200edb          	.4byte	0x44200edb
   1338c:	44d6                	.2byte	0x44d6
   1338e:	44d5                	.2byte	0x44d5
   13390:	44d4                	.2byte	0x44d4
   13392:	d4d344d3          	.4byte	0xd4d344d3
   13396:	d6d5                	.2byte	0xd6d5
   13398:	d9d8                	.2byte	0xd9d8
   1339a:	dbda                	.2byte	0xdbda
   1339c:	100e                	.2byte	0x100e
   1339e:	d244                	.2byte	0xd244
   133a0:	c944                	.2byte	0xc944
   133a2:	c844                	.2byte	0xc844
   133a4:	c144                	.2byte	0xc144
   133a6:	0e44                	.2byte	0xe44
   133a8:	0000                	.2byte	0x0
	...
